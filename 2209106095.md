# LAPORAN AUDIT PROPOSAL SKRIPSI

**Mahasiswa:** Dinda Ayu Aprilia (2209106095)

**Judul:** Implementasi dan Evaluasi Kinerja Quick Sort dan Binary Search untuk Pengelolaan Data Praktikan pada Sistem Praktikum Berbasis Web

**Program Studi:** Informatika, Fakultas Teknik, Universitas Mulawarman

**Dosen Pembimbing I:** Ir. Novianti Puspitasari, S.Kom., M.Eng.

**Dosen Pembimbing II:** Anton Prafanto, S.Kom., MT

---

## RINGKASAN EKSEKUTIF

Proposal skripsi ini membahas pengembangan sistem praktikum berbasis web dengan implementasi algoritma Quick Sort dan Binary Search untuk mengelola data praktikan Pendidikan Agama Islam di Fakultas Teknik Universitas Mulawarman. Secara keseluruhan, proposal ini menunjukkan **struktur yang baik, landasan teoritis yang memadai, dan metodologi yang terencana**. Namun, terdapat beberapa aspek yang perlu diperbaiki dan diperjelas agar penelitian lebih fokus dan dapat diimplementasikan dengan optimal.

**Penilaian Keseluruhan: 7.5/10**

---

## A. ANALISIS BAB I - PENDAHULUAN

### 1. Latar Belakang ‚úì BAIK

**Kekuatan:**
- Identifikasi masalah jelas: pengelolaan data praktikum manual menggunakan spreadsheet yang terfragmentasi
- Data kuantitatif mendukung (500-700 praktikan, waktu pencarian 2-3 menit per data)
- Argumentasi logis mengenai kebutuhan sistem terintegrasi
- Gap analysis antara kondisi saat ini dan yang diharapkan tersampaikan dengan baik

**Kelemahan & Saran Perbaikan:**

‚ö†Ô∏è **CRITICAL - Justifikasi Pemilihan Algoritma Lemah**
> Halaman 2: "Karakteristik pengelolaan data praktikan yang melibatkan ratusan hingga ribuan entri membutuhkan algoritma pengurutan yang efisien..."

**Masalah:**
- Tidak ada analisis komparatif mengapa Quick Sort dipilih dibanding Merge Sort, Heap Sort, atau bahkan sorting bawaan database (ORDER BY dalam SQL)
- Pada konteks web application dengan database MySQL, sorting biasanya dilakukan di level database yang jauh lebih efisien
- Tidak dijelaskan apakah 500-700 data benar-benar membutuhkan optimasi algoritma sorting manual

**Rekomendasi:**
```
Tambahkan paragraf yang menjelaskan:
1. Perbandingan performa sorting di database vs aplikasi layer
2. Skenario spesifik kapan Quick Sort manual dibutuhkan (real-time filtering? dynamic grouping?)
3. Justifikasi teknis mengapa tidak cukup menggunakan "ORDER BY nim ASC" di SQL
```

‚ö†Ô∏è **MODERATE - Scope Creep Potential**
> Halaman 2: "...pencarian linear ketika jumlah data semakin besar"

**Masalah:**
- Dalam praktik web development modern dengan database indexing, pencarian berdasarkan primary key (NIM) sudah O(log n) bahkan O(1) dengan hash index
- Binary Search manual jarang diimplementasikan ketika sudah ada database indexing

**Rekomendasi:**
```
Perjelas konteks penggunaan Binary Search:
- Apakah untuk pencarian in-memory setelah data di-fetch?
- Apakah untuk fitur autocomplete/live search?
- Apakah untuk operasi tanpa query database?

Atau pertimbangkan untuk fokus pada "implementasi caching dengan binary search
untuk mengurangi query database" yang lebih relevan.
```

### 2. Rumusan Masalah ‚ö†Ô∏è PERLU DIPERJELAS

**Current:**
> "Bagaimana implementasi serta kinerja algoritma Quick Sort dan Binary Search dalam sistem praktikum berbasis web berdasarkan waktu eksekusi, latensi sistem, dan pengaruh ukuran dataset..."

**Masalah:**
- Terlalu luas dan mencakup 2 aspek berbeda (implementasi + evaluasi kinerja)
- Tidak spesifik tentang apa yang ingin dibandingkan

**Rekomendasi Revisi:**
```
Pecah menjadi 2-3 sub-rumusan:

1. Bagaimana merancang dan mengimplementasikan algoritma Quick Sort dengan
   metode pivot Median of Seven (MO7) untuk pengurutan data praktikan dalam
   sistem berbasis web?

2. Bagaimana merancang dan mengimplementasikan algoritma Binary Search untuk
   pencarian data praktikan pada dataset terurut?

3. Bagaimana perbandingan kinerja kombinasi Quick Sort + Binary Search dengan
   metode default database (ORDER BY + LIKE/WHERE) dalam hal waktu eksekusi,
   penggunaan memori, dan latensi respons sistem pada variasi dataset
   (100, 500, 1000 entri)?
```

### 3. Batasan Masalah ‚úì CUKUP BAIK

**Sudah Baik:**
- Scope objek penelitian jelas (Praktikum PAI FT Unmul 2024-2025)
- Variasi dataset terdefinisi (100, 500, 1000 entri)
- Peran stakeholder diperjelas

**Perlu Ditambahkan:**
```
6. Algoritma Quick Sort menggunakan metode pivot Median of Seven (MO7)
   sebagaimana telah dianalisis pada penelitian terkait (Tahsin et al., 2024)

7. Evaluasi performa dilakukan pada environment lokal (localhost) dengan
   spesifikasi hardware yang terkontrol untuk konsistensi hasil

8. Sistem tidak mencakup fitur notifikasi real-time, integrasi payment,
   atau single sign-on dengan sistem universitas lainnya

9. Pengujian keamanan (security testing) tidak termasuk dalam scope,
   fokus hanya pada functional testing dan performance testing
```

### 4. Tujuan Penelitian ‚úì BAIK

Tujuan penelitian sudah sejalan dengan rumusan masalah dan terukur.

### 5. Manfaat Penelitian ‚úì BAIK

Manfaat untuk berbagai pihak sudah dijelaskan dengan baik dan realistis.

### 6. Kontribusi Penelitian ‚ö†Ô∏è KURANG SPESIFIK

**Current:**
> "...menyediakan data empiris mengenai perilaku performa algoritma pada berbagai ukuran dataset praktikan..."

**Masalah:**
- Kontribusi ilmiah tidak cukup kuat
- "Data empiris performa algoritma" sudah banyak penelitian serupa

**Rekomendasi:**
```
Perkuat kontribusi dengan:

1. KONTRIBUSI PRAKTIS:
   "Menghasilkan sistem praktikum berbasis web yang dapat langsung
   digunakan oleh Tim Praktikum PAI FT Unmul dengan performa 80%
   lebih cepat dari metode spreadsheet manual"

2. KONTRIBUSI METODOLOGIS:
   "Menyediakan framework evaluasi performa algoritma sorting-searching
   pada web application dengan mempertimbangkan trade-off antara
   database-level operation vs application-level operation"

3. KONTRIBUSI TEORITIS (opsional):
   "Memberikan rekomendasi threshold ukuran dataset untuk pemilihan
   strategi sorting-searching yang optimal pada sistem praktikum
   berbasis web dengan PHP-MySQL stack"
```

---

## B. ANALISIS BAB II - TINJAUAN PUSTAKA

### 1. Penelitian Terkait ‚úì SANGAT BAIK

**Kekuatan:**
- 10 penelitian terkait dengan variasi yang baik (algoritma, metodologi, domain aplikasi)
- Setiap penelitian diringkas dengan struktur: algoritma ‚Üí temuan ‚Üí relevansi
- Sudah mencakup penelitian terbaru (2020-2025)
- Ada penelitian yang spesifik tentang MO7 pada Quick Sort (Tahsin et al., 2024)

**Catatan Positif:**
- Penelitian #2 (Tahsin et al., 2024) sangat relevan dan bisa dijadikan justifikasi kuat untuk pemilihan MO7
- Penelitian #5 (Meidiansyah et al., 2025) hampir identik dengan scope penelitian ini - bagus untuk benchmark

**Saran Minor:**
```
Tambahkan 1-2 penelitian tentang:
- Performance comparison: database sorting vs application sorting
- Caching strategies untuk web applications
- Index optimization pada MySQL untuk operasi pencarian
```

### 2. Perbedaan dengan Penelitian Sebelumnya ‚úì BAIK

Sudah dijelaskan dengan baik bahwa fokus penelitian ini adalah **integrasi Quick Sort + Binary Search dalam satu sistem nyata** dengan evaluasi performa menyeluruh.

### 3. Teori Pendukung ‚ö†Ô∏è BELUM LENGKAP (halaman terputus)

**Yang Terlihat:**
- 2.2.1 Sistem Berbasis Web
- 2.2.2 Pengelolaan Data Praktikum
- 2.2.3 Algoritma dan Kompleksitas Waktu
- 2.2.4 Algoritma Sorting (Quick Sort)
- 2.2.5 Algoritma Searching (Binary Search)
- 2.2.6 Kombinasi Quick Sort dan Binary Search
- 2.2.7 Metodologi Pengembangan Sistem

**Yang Perlu Dipastikan Lengkap:**

‚úì Teori Quick Sort harus mencakup:
- Penjelasan divide-and-conquer
- Analisis best/average/worst case
- Penjelasan pivot selection strategy (terutama MO7)
- Pseudocode atau flowchart

‚úì Teori Binary Search harus mencakup:
- Prerequisite: data terurut
- Kompleksitas O(log n) dengan penjelasan matematis
- Perbandingan dengan Linear Search
- Pseudocode

‚ö†Ô∏è **HARUS ADA - Teori Database Indexing:**
```
Tambahkan sub-bab:
2.2.8 Database Indexing dan Query Optimization
- B-Tree Index pada MySQL
- Perbandingan performa indexed search vs binary search
- Trade-off memory vs speed

Ini penting untuk menjustifikasi kapan binary search manual
lebih baik daripada database index.
```

### 4. Perancangan Sistem ‚úì BAIK

Sudah lengkap dengan ERD, Flowchart, DFD, Use Case Diagram.

### 5. Perancangan Website ‚úì BAIK

Stack teknologi sudah tepat: PHP, Laravel, MySQL, HTML/CSS/JavaScript.

---

## C. ANALISIS BAB III - METODOLOGI PENELITIAN

### 1. Tahapan Pelaksanaan Penelitian ‚úì BAIK

**Kekuatan:**
- Menggunakan metode R&D dengan model Waterfall yang tepat untuk sistem terstruktur
- Tahapan jelas dan sistematis

**Saran Perbaikan:**

‚ö†Ô∏è **Fase Evaluasi Kurang Detail**
```
Tambahkan tahapan:
1. Data Collection Phase
   - Pengumpulan data real praktikan (dengan anonymization)
   - Pembuatan synthetic dataset untuk variasi 100, 500, 1000 entri

2. Benchmark Definition Phase
   - Mendefinisikan baseline: waktu pencarian manual di spreadsheet
   - Mendefinisikan baseline: query database tanpa algoritma custom

3. Controlled Testing Phase
   - Testing environment specification
   - Number of test iterations (minimal 30x untuk reliabilitas statistik)
   - Metrics collection method (server-side timing, client-side timing, atau keduanya?)
```

### 2. Pengumpulan Data ‚úì BAIK

Sudah mencakup observasi, wawancara, studi pustaka.

**Tambahan yang Disarankan:**
```
- Data existing: jumlah praktikan per periode 3 tahun terakhir (untuk trend analysis)
- Data pain points: berapa lama rata-rata asisten menghabiskan waktu untuk
  rekapitulasi nilai per periode?
- Baseline metrics: waktu rata-rata pencarian data di spreadsheet saat ini
```

### 3. Perancangan Data (ERD) ‚úì SANGAT BAIK

ERD terlihat lengkap dengan entitas:
- users (PK: id)
- praktikan (PK: nim)
- asisten
- periode
- kelompok
- kategori_penilaian
- materi
- presensi
- nilai_pretest_posttest
- nilai_praktikum

**Relasi sudah tepat dengan normalisasi yang baik.**

**Saran Minor:**
```
Pertimbangkan tambahan:
- tabel "logs_search" untuk mencatat waktu eksekusi binary search
- tabel "logs_sorting" untuk mencatat waktu eksekusi quick sort
- Ini penting untuk evaluasi performa sistem
```

### 4. Perancangan Proses ‚úì SANGAT BAIK

**Use Case Diagram, DFD, dan Flowchart sudah lengkap.**

**Poin Penting yang Terlihat:**
- Flowchart Quick Sort dengan MO7 (Gambar 3.4.10, 3.4.11)
- Flowchart Binary Search (Gambar 3.4.9)
- Flowchart Partition (Gambar 3.4.12)

‚úì Ini menunjukkan mahasiswa memahami implementasi algoritma secara detail.

### 5. Perancangan Tampilan (Wireframe) ‚úì BAIK

22 wireframe untuk berbagai role (Praktikan, Asisten, PJ) menunjukkan **perencanaan UI/UX yang matang**.

### 6. Perancangan Pengujian ‚úì CUKUP BAIK

**Black Box Testing sudah mencakup:**
- Pengujian Login, Registrasi
- Pengujian fitur per role
- Pengujian navigasi

**‚ö†Ô∏è CRITICAL - Kurang Pengujian Performa Algoritma**

Yang ada (halaman 70-73):
```
3.7 Evaluasi Kinerja Algoritma
3.7.1 Objek Evaluasi
3.7.2 Parameter Evaluasi
3.7.3 Dataset dan Variasi Ukuran Data
3.7.4 Skenario dan Prosedur Pengujian
3.7.5 Teknik Pengukuran
3.7.6 Lingkungan Pengujian
3.7.7 Analisis Hasil Evaluasi
```

‚úì Struktur sudah baik, tapi **perlu dipastikan isinya detail dan terukur**.

**Harus Diperjelas:**

```
SKENARIO PENGUJIAN HARUS MENCAKUP:

A. Pengujian Quick Sort:
   1. Best case: data sudah terurut
   2. Average case: data acak
   3. Worst case: data reverse sorted

   Metrics:
   - Waktu eksekusi (ms) - diukur dengan microtime(true) PHP
   - Jumlah comparison
   - Jumlah swap
   - Memory usage (memory_get_peak_usage() PHP)

B. Pengujian Binary Search:
   1. Best case: target di tengah
   2. Average case: target random
   3. Worst case: target tidak ada

   Metrics:
   - Waktu eksekusi (ms)
   - Jumlah iterasi
   - Latensi respons HTTP (dengan browser developer tools)

C. Pengujian Sistem Terintegrasi:
   - Waktu total dari request hingga response (termasuk rendering)
   - Bandingkan dengan: database query standard (ORDER BY + WHERE)

D. Variasi Dataset:
   - 100 entri
   - 500 entri
   - 1000 entri
   - (tambahan) 5000 entri untuk melihat scalability

E. Number of Iterations:
   - Minimal 30 kali pengujian per skenario
   - Hitung mean, median, standard deviation
   - Buang outliers (gunakan IQR method)
```

### 7. Waktu dan Tempat Penelitian ‚úì BAIK

Tabel jadwal penelitian sudah ada (Tabel 3.7).

---

## D. ASPEK TEKNIS YANG PERLU DIPERHATIKAN

### 1. ‚ö†Ô∏è IMPLEMENTASI QUICK SORT - PERLU KLARIFIKASI

**Pertanyaan Kritis:**

```
Q1: Di mana Quick Sort akan dijalankan?
    A. Server-side (PHP) setelah fetch dari database?
    B. Client-side (JavaScript) untuk sorting tampilan?
    C. Keduanya?

Q2: Kapan Quick Sort dipanggil?
    A. Setiap kali ada request pencarian/filtering?
    B. Saat generate laporan nilai akhir?
    C. Saat export data ke Excel/PDF?

Q3: Mengapa tidak cukup dengan SQL ORDER BY?
    - ORDER BY sudah sangat dioptimasi di MySQL
    - Untuk 1000 data, perbedaan waktu akan sangat kecil (< 10ms)
```

**Rekomendasi:**

```
OPSI 1: Fokus pada kasus yang jelas membutuhkan sorting custom
Contoh:
- Multi-criteria sorting yang kompleks (e.g., sort by nilai DESC,
  then by presensi DESC, then by nama ASC)
- Weighted sorting untuk ranking praktikan

OPSI 2: Bandingkan secara eksplisit
- Implementasi 2 versi: dengan Quick Sort manual vs dengan ORDER BY
- Ukur dan bandingkan performanya
- Kesimpulan: kapan Quick Sort manual worth it, kapan tidak

OPSI 3: Fokus pada in-memory operation
- Fetch semua data periode aktif ke memory (caching)
- Implementasi Quick Sort untuk real-time filtering di aplikasi
- Ini mengurangi database query berulang
```

### 2. ‚ö†Ô∏è IMPLEMENTASI BINARY SEARCH - PERLU KLARIFIKASI

**Pertanyaan Kritis:**

```
Q1: Apa yang dicari dengan Binary Search?
    A. Praktikan berdasarkan NIM? ‚Üí Database index sudah O(1) dengan PRIMARY KEY
    B. Praktikan berdasarkan nama? ‚Üí LIKE query dengan index sudah cukup cepat
    C. Nilai dalam range tertentu? ‚Üí Mungkin lebih relevan

Q2: Data dicari dari mana?
    A. Dari database langsung? ‚Üí Index database lebih cepat
    B. Dari array yang sudah di-fetch? ‚Üí Binary Search relevan di sini
    C. Dari cached data? ‚Üí Binary Search sangat relevan

Q3: Apakah data selalu terurut?
    - Binary Search membutuhkan data terurut
    - Overhead untuk sorting dulu mungkin tidak worth it untuk single search
```

**Rekomendasi:**

```
SKENARIO YANG MASUK AKAL:

SKENARIO 1: Autocomplete Search
- User mengetik NIM/nama di search box
- Fetch data periode aktif ke JavaScript array (sorted)
- Implementasi Binary Search di JavaScript untuk live filtering
- Lebih responsif karena tidak perlu AJAX call berulang

SKENARIO 2: Range Query
- Cari praktikan dengan nilai antara 75-85
- Jika data sudah sorted by nilai, Binary Search bisa menemukan
  start dan end index dengan cepat
- Lebih efisien dari WHERE nilai BETWEEN 75 AND 85 jika data di-cache

SKENARIO 3: Periodic Batch Processing
- Setiap akhir semester, generate ranking semua praktikan
- Fetch all data, sort dengan Quick Sort, simpan di cache/memory
- Binary Search untuk lookup cepat saat generate sertifikat/transkrip
```

### 3. ‚úì TEKNOLOGI STACK - SUDAH TEPAT

- **Backend:** PHP Laravel ‚Üí Tepat, mature, well-documented
- **Frontend:** HTML/CSS/JavaScript ‚Üí Standard dan sesuai
- **Database:** MySQL ‚Üí Tepat untuk relational data
- **Server:** XAMPP ‚Üí Sesuai untuk development

**Saran Tambahan:**
```
- Gunakan Laravel Query Builder untuk baseline comparison
- Implementasi caching (Redis/Memcached) untuk performa optimal
- Gunakan Laravel Eloquent ORM tapi measure raw query juga
```

---

## E. KELEMAHAN STRUKTURAL PROPOSAL

### 1. ‚ö†Ô∏è MISSING: Analisis Kompleksitas Algoritma yang Mendalam

**Yang Seharusnya Ada:**

```
Tambahkan sub-bab di BAB II:

2.2.9 Analisis Kompleksitas Waktu Quick Sort dengan Pivot MO7

- Kompleksitas Best Case: O(n log n)
  Terjadi ketika pivot selalu membagi data menjadi 2 bagian seimbang
  Dengan MO7, probabilitas ini meningkat karena pivot mendekati median sebenarnya

- Kompleksitas Average Case: O(n log n)
  Penelitian Tahsin et al. (2024) menunjukkan MO7 memberikan waktu
  eksekusi 0.0112 detik, lebih baik dari MO3 (0.0124 detik)

- Kompleksitas Worst Case: O(n¬≤)
  Masih mungkin terjadi jika data memiliki banyak nilai duplicate
  Atau jika MO7 sampling kebetulan memilih pivot buruk

- Trade-off MO7:
  + Lebih akurat dalam memilih pivot
  + Mengurangi probabilitas worst case
  - Overhead 7x comparison untuk setiap pivot selection
  - Untuk dataset kecil (< 100), overhead ini mungkin tidak worth it

REKOMENDASI:
Untuk sistem praktikum dengan 500-1000 data, MO7 adalah pilihan optimal
berdasarkan benchmark Tahsin et al. (2024).

2.2.10 Analisis Kompleksitas Waktu Binary Search

- Kompleksitas: O(log n)
  Untuk 1000 data, maksimal 10 iterasi (2^10 = 1024)
  Untuk 10000 data, maksimal 14 iterasi (2^14 = 16384)

- Prerequisite: Data HARUS terurut
  Jika data belum terurut, overhead sorting O(n log n) harus diperhitungkan
  Total complexity: O(n log n) + O(log n) ‚âà O(n log n)

- Perbandingan dengan Database Index:
  MySQL B-Tree Index: O(log n) untuk WHERE clause
  Binary Search manual: O(log n) untuk in-memory array

  Perbedaan:
  - Database index: I/O overhead, query parsing
  - Binary Search: No I/O, tapi harus fetch all data dulu

REKOMENDASI:
Binary Search lebih efisien jika:
1. Data sudah di-cache di memory (avoid repeated database query)
2. Melakukan multiple searches pada dataset yang sama
3. Real-time filtering di client-side
```

### 2. ‚ö†Ô∏è MISSING: Baseline Comparison

**Yang Harus Ditambahkan:**

```
Tambahkan di Metodologi (BAB III):

3.7.8 Baseline Comparison

Untuk mengukur efektivitas implementasi Quick Sort + Binary Search,
sistem akan dibandingkan dengan 2 baseline:

BASELINE 1: Metode Saat Ini (Spreadsheet Manual)
- Waktu rata-rata pencarian 1 data: 2-3 menit (berdasarkan observasi)
- Waktu rekapitulasi nilai 500 praktikan: ¬± 4-6 jam
- Error rate: ¬± 5% (based on historical data correction)

BASELINE 2: Standard Database Query
Implementasi WITHOUT custom sorting/searching:

```php
// Baseline query
$data = DB::table('praktikan')
          ->join('nilai_praktikum', 'praktikan.nim', '=', 'nilai_praktikum.nim')
          ->where('periode_id', $periode_id)
          ->orderBy('nim', 'asc')  // MySQL ORDER BY
          ->get();

// Search
$result = DB::table('praktikan')
            ->where('nim', 'LIKE', "%$keyword%")  // MySQL LIKE dengan index
            ->first();
```

EKSPEKTASI HASIL:
- Quick Sort + Binary Search minimal 50% lebih cepat dari Baseline 1
- Quick Sort + Binary Search kompetitif (selisih < 20%) dengan Baseline 2
  untuk dataset < 1000, atau lebih unggul untuk repeated operations
```

### 3. ‚ö†Ô∏è MISSING: Threat to Validity

**Tambahkan:**

```
3.8 Ancaman Terhadap Validitas Penelitian

3.8.1 Internal Validity
- Variasi performa hardware: pengujian dilakukan pada single machine
  Mitigasi: dokumentasikan spesifikasi lengkap, ulangi di 2-3 environment

- Caching effects: pengujian berulang mungkin benefit dari OS/browser cache
  Mitigasi: clear cache setiap iterasi, randomize test order

- Network latency: waktu respons dipengaruhi jaringan lokal
  Mitigasi: testing dilakukan di localhost untuk isolasi

3.8.2 External Validity
- Ukuran dataset terbatas (max 1000): belum mewakili big data scenario
  Mitigasi: tambahkan stress test dengan 5000-10000 data

- Data praktikum spesifik: mungkin tidak generalisir ke domain lain
  Mitigasi: jelaskan karakteristik data (categorical, numerical, text)

3.8.3 Construct Validity
- Waktu eksekusi dipengaruhi banyak faktor (GC, concurrent process)
  Mitigasi: multiple runs, statistical analysis (mean, std dev)
```

---

## F. KEKUATAN PROPOSAL

### ‚úÖ Yang Sudah Sangat Baik:

1. **Dokumentasi Flowchart Algoritma Lengkap**
   - Flowchart Quick Sort dengan MO7 (detail pemilihan pivot)
   - Flowchart Partition Process
   - Flowchart Binary Search
   - Ini menunjukkan pemahaman mendalam terhadap implementasi

2. **Use Case dan ERD Komprehensif**
   - 3 role user (Praktikan, Asisten, PJ)
   - Database design sudah normalized
   - Relasi antar tabel jelas

3. **Wireframe UI/UX Lengkap (22 halaman)**
   - Menunjukkan sistem sudah dipikirkan sampai detail UX
   - Coverage untuk semua fitur dan role

4. **Literature Review Solid**
   - 10 penelitian terkait dengan variasi baik
   - Ada penelitian yang sangat relevan (Meidiansyah et al., 2025; Tahsin et al., 2024)
   - Perbedaan dengan penelitian terdahulu jelas

5. **Metodologi Terstruktur**
   - R&D dengan Waterfall cocok untuk jenis penelitian ini
   - Tahapan evaluasi kinerja sudah direncanakan

---

## G. REKOMENDASI PRIORITAS

### üî¥ PRIORITY 1 - CRITICAL (Harus Diperbaiki Sebelum Sidang)

1. **Klarifikasi Justifikasi Algoritma**
   - Tambahkan analisis: kapan Quick Sort manual lebih baik dari SQL ORDER BY
   - Tambahkan analisis: kapan Binary Search manual lebih baik dari Database Index
   - Berikan skenario konkret penggunaan di sistem

2. **Perbaiki Rumusan Masalah**
   - Pecah menjadi sub-rumusan yang lebih spesifik dan terukur

3. **Lengkapi Detail Pengujian Performa**
   - Skenario pengujian harus detail (best/average/worst case)
   - Metrics harus terdefinisi (apa yang diukur, bagaimana cara mengukur)
   - Baseline comparison harus ada

4. **Tambahkan Teori Database Indexing**
   - Penting untuk menjustifikasi kapan algoritma manual lebih baik

### üü° PRIORITY 2 - IMPORTANT (Disarankan Diperbaiki)

5. **Perkuat Kontribusi Penelitian**
   - Kontribusi ilmiah/metodologis perlu lebih spesifik

6. **Tambahkan Analisis Kompleksitas Mendalam**
   - Analisis matematis complexity dengan MO7
   - Perbandingan dengan complexity database operations

7. **Tambahkan Threat to Validity**
   - Menunjukkan kesadaran terhadap limitasi penelitian

8. **Expand Dataset Variasi**
   - Tambahkan testing dengan 5000 data untuk scalability analysis

### üü¢ PRIORITY 3 - NICE TO HAVE (Opsional)

9. **Tambahkan Penelitian Terkait tentang Database Optimization**

10. **Pertimbangkan Implementasi Caching Strategy**
    - Redis/Memcached untuk performa optimal
    - Bisa jadi additional evaluation point

---

## H. PERTANYAAN UNTUK MAHASISWA

Sebelum melanjutkan, mahasiswa perlu menjawab pertanyaan-pertanyaan ini untuk memperjelas scope:

1. **Kapan sebenarnya Quick Sort akan digunakan dalam sistem?**
   - Setiap request? Batch processing? Export laporan?

2. **Apa alasan kuat mengapa tidak cukup menggunakan SQL ORDER BY yang sudah sangat dioptimasi?**

3. **Untuk fitur apa Binary Search akan diimplementasikan?**
   - Autocomplete search? Range query? Lookup praktikan?

4. **Apakah akan menggunakan caching (Redis/Memcached)?**
   - Ini sangat mempengaruhi skenario penggunaan Binary Search

5. **Apakah data praktikan memiliki karakteristik khusus yang membuat algoritma custom lebih efektif?**
   - Banyak duplicate? Frequently updated? Always sorted by nature?

6. **Apakah ada constraint khusus dari Tim Praktikum PAI terkait infrastruktur?**
   - Shared hosting? Limited resource? Specific software requirements?

---

## I. KESIMPULAN AUDIT

### Overall Assessment

| Aspek | Nilai | Komentar |
|-------|-------|----------|
| **BAB I - Pendahuluan** | 7/10 | Latar belakang baik, tapi justifikasi algoritma perlu diperkuat |
| **BAB II - Tinjauan Pustaka** | 8.5/10 | Literature review solid, teori pendukung lengkap |
| **BAB III - Metodologi** | 7.5/10 | Struktur baik, tapi detail pengujian perlu diperjelas |
| **Perancangan Sistem** | 9/10 | ERD, DFD, Flowchart, Wireframe sangat baik |
| **Kelayakan Teknis** | 6/10 | Ada gap antara teori algoritma dengan praktik web dev |
| **Originalitas** | 7/10 | Kombinasi Quick Sort + Binary Search di sistem nyata cukup unik |

**NILAI KESELURUHAN: 7.5/10**

### Verdict

‚úÖ **PROPOSAL LAYAK DILANJUTKAN** dengan perbaikan pada aspek-aspek kritis di atas.

### Kekuatan Utama
1. Dokumentasi teknis sangat lengkap (flowchart, ERD, wireframe)
2. Literature review solid dengan 10 penelitian relevan
3. Metodologi terstruktur dan sistematis
4. Mahasiswa menunjukkan pemahaman mendalam terhadap algoritma

### Kelemahan Utama
1. **Gap antara teori algoritma dengan praktik web development**
   - Kurang justifikasi mengapa perlu algoritma manual vs database operations

2. **Detail evaluasi performa kurang spesifik**
   - Skenario pengujian perlu lebih detail
   - Baseline comparison belum ada

3. **Kontribusi ilmiah kurang kuat**
   - "Evaluasi performa algoritma" tidak cukup unik

### Recommendations Summary

**Untuk Mahasiswa:**
1. Fokus pada 1-2 use case jelas yang benar-benar benefit dari algoritma custom
2. Implementasikan 2 versi: dengan dan tanpa algoritma custom untuk comparison
3. Perjelas detail pengujian dan metrics
4. Tambahkan analisis database indexing untuk context

**Untuk Pembimbing:**
1. Diskusikan kembali justifikasi pemilihan algoritma manual vs database operations
2. Pastikan mahasiswa memahami trade-off dan bisa defend pilihannya
3. Review detail skenario pengujian sebelum implementasi
4. Pertimbangkan untuk fokuskan pada "sistem praktikum dengan performa optimal" daripada terlalu fokus pada algoritma spesifik

---

## J. ACTION ITEMS

### Untuk Mahasiswa (Deadline: Sebelum Bimbingan Berikutnya)

- [ ] Revisi Rumusan Masalah sesuai rekomendasi
- [ ] Tambahkan justifikasi pemilihan Quick Sort vs SQL ORDER BY
- [ ] Tambahkan justifikasi pemilihan Binary Search vs Database Index
- [ ] Lengkapi detail skenario pengujian performa
- [ ] Tambahkan sub-bab tentang Database Indexing di Tinjauan Pustaka
- [ ] Tambahkan bagian Baseline Comparison di Metodologi
- [ ] Tambahkan analisis kompleksitas mendalam di Tinjauan Pustaka
- [ ] Perkuat kontribusi penelitian dengan lebih spesifik

### Untuk Pembimbing

- [ ] Diskusi mendalam tentang justifikasi algoritma
- [ ] Review dan approve detail pengujian performa
- [ ] Berikan guidance terkait balance antara fokus algoritma vs fokus sistem
- [ ] Pertimbangkan scope adjustment jika terlalu luas

---

**Tanggal Audit:** 14 Januari 2026
**Auditor:** Anton Prafanto, S.Kom., MT (Dosen Pembimbing II)
**Status:** REVISI DIPERLUKAN - PROPOSAL LAYAK DENGAN PERBAIKAN

---

## K. ANALISIS LANJUTAN - BAB II & BAB III (HALAMAN 26-50)

### 1. Teori Pendukung (Lanjutan) ‚úì BAIK

**Yang Sudah Lengkap (hal. 12-24):**

#### 2.2.1 Sistem Berbasis Web ‚úì
- Definisi jelas dan kontekstual
- Referensi relevan (Lontaan & Sinadia, 2024)
- Kelebihan sistem web explained dengan baik

#### 2.2.2 Pengelolaan Data Praktikum ‚úì
- Problem statement jelas
- Konteks praktikum explained
- Referensi mendukung (Gunawan et al., 2023)

#### 2.2.3 Algoritma dan Kompleksitas Waktu ‚úì
- Penjelasan kompleksitas O(n¬≤), O(n log n), O(log n) ada
- Konteks scalability explained
- Referensi (Wang et al., 2024)

**‚ö†Ô∏è CRITICAL - Masih Kurang Depth:**
```
MISSING: Analisis matematis konkret
Contoh yang seharusnya ada:

Untuk Quick Sort O(n log n):
- n = 1000 data ‚Üí ¬±10,000 operasi (1000 √ó log‚ÇÇ(1000) ‚âà 1000 √ó 10)
- n = 10,000 data ‚Üí ¬±133,000 operasi

Untuk Binary Search O(log n):
- n = 1000 data ‚Üí maksimal 10 iterasi (2¬π‚Å∞ = 1024)
- n = 10,000 data ‚Üí maksimal 14 iterasi (2¬π‚Å¥ = 16,384)

VS SQL ORDER BY dengan B-Tree Index (also O(log n) but optimized):
- Overhead: query parsing, I/O operations
- Benefit: highly optimized, parallel processing di DB engine

Kapan aplikasi-level sorting worth it?
‚Üí Ketika data sudah di-cache dan perlu multiple operations
‚Üí Ketika perlu custom sorting logic yang complex
```

#### 2.2.4 Algoritma Sorting (Quick Sort) ‚úì BAIK
**Kekuatan:**
- Penjelasan divide-and-conquer ada
- Kompleksitas explained (best/avg/worst case)
- MO7 (Median of Seven) explained dengan referensi kuat (Tahsin et al., 2024)
- Justifikasi pemilihan MO7 vs MO3/MO5/MO9 jelas

**Catatan Positif:**
> "Hasil analisis eksperimental menunjukkan bahwa penggunaan pivot Median of Seven memberikan waktu eksekusi yang lebih efisien dibandingkan beberapa metode pemilihan pivot lainnya"

‚úì Ini adalah justifikasi yang kuat berdasarkan literatur.

#### 2.2.5 Algoritma Searching (Binary Search) ‚úì BAIK
**Kekuatan:**
- Penjelasan algoritma jelas
- Prerequisite (data terurut) explained
- Kompleksitas O(log n) explained
- Referensi mendukung (Meidiansyah et al., 2025)

**‚ö†Ô∏è MINOR - Perlu Tambahan:**
```
Tambahkan perbandingan:
Binary Search vs Database Index Search

Binary Search (in-memory array):
+ No I/O overhead
+ Predictable performance
+ Good for cached data
- Requires pre-fetching all data
- Requires sorting first

Database Index (B-Tree):
+ Optimized by DBMS
+ No need to fetch all data
+ Built-in dengan CREATE INDEX
- I/O overhead
- Query parsing time
```

#### 2.2.6 Kombinasi Quick Sort dan Binary Search ‚úì SANGAT BAIK
**Kekuatan:**
- Menjelaskan sinergi kedua algoritma
- Referensi penelitian identik (Meidiansyah et al., 2025) yang membuktikan efektivitas kombinasi
- Data empiris: dataset 1000-10000 sudah tested

**Catatan Positif:**
Mahasiswa aware bahwa ini bukan konsep baru, tapi implementasi pada konteks praktikum PAI yang belum ada.

#### 2.2.7 Metodologi Pengembangan Sistem ‚úì BAIK
**Kekuatan:**
- Justifikasi pemilihan Waterfall jelas dan tepat
- Alasan: kebutuhan stabil, terstruktur, dapat direncanakan
- Diagram Waterfall included
- Referensi (Sallu et al., 2023)

### 2. Perancangan Sistem ‚úì SANGAT BAIK

#### 2.3.1 ERD ‚úì
- Simbol dan keterangan lengkap (Tabel 2.3.1)
- Definisi jelas

#### 2.3.2 Flowchart ‚úì
- Simbol standar lengkap (Tabel 2.3.2)
- Follows best practice

#### 2.3.3 DFD ‚úì
- Simbol dan keterangan lengkap (Tabel 2.3.3)
- Penjelasan level abstraksi baik
- Referensi (Aleryani, 2024)

#### 2.3.4 Use Case Diagram ‚úì
- Simbol lengkap (Tabel 2.3.4)
- Konteks UML explained
- Referensi (Aleryani, 2024)

### 3. Perancangan Website ‚úì SANGAT BAIK

**Stack Teknologi Explained dengan Detail:**

#### 2.4.1 PHP ‚úì
- Server-side processing explained
- Open source mentioned
- Referensi (Nova, 2025)

#### 2.4.2 HTML ‚úì
- Blade templating mentioned (Laravel context)
- Separation of concerns explained
- Responsiveness mentioned

#### 2.4.3 CSS ‚úì BAIK
- Penjelasan panjang dan detail
- Visual design aspects explained
- Responsiveness untuk mobile/tablet/desktop mentioned
- Referensi (Tanjung et al., 2025)

#### 2.4.4 JavaScript ‚úì
- Client-side interactivity explained
- Node.js mentioned untuk server-side
- Modern frameworks mentioned (React, Angular, Vue.js)
- Referensi (Raehan et al., 2025)

**Catatan:** Meskipun framework modern disebutkan, proposal tidak menggunakannya - ini OK, tapi bisa diklarifikasi akan pakai vanilla JS atau jQuery.

#### 2.4.5 Framework Laravel ‚úì SANGAT BAIK
**Kekuatan:**
- MVC architecture explained
- Eloquent ORM mentioned ‚Üí relevant untuk sorting/searching
- Blade Template Engine explained
- Controller role explained dengan konteks algoritma:
  > "Controller bertugas menghubungkan permintaan pengguna dengan logika pengolahan data, termasuk pemanggilan fungsi Quick Sort untuk pengurutan dan Binary Search untuk pencarian."

‚úì **Ini adalah penjelasan konkret tentang WHERE algoritma akan digunakan!**

- Routing, middleware, validation, migration mentioned
- Scalability mentioned
- Referensi (Rahmawati & Sumarsono, 2024)

#### 2.4.6 XAMPP ‚úì
- Localhost development explained
- Components mentioned (Apache, MySQL, PHP, Perl)
- Testing & debugging purpose explained

#### 2.4.7 MySQL Database ‚úì BAIK
**Kekuatan:**
- Role sebagai data storage explained
- Data structure listed (NIM, nama, kelompok, nilai, etc.)
- Compatibility dengan Eloquent ORM mentioned
- Performa & integrasi explained
- Referensi (Lontaan & Sinadia, 2024)

**‚ö†Ô∏è MINOR - Perlu Tambahan:**
```
Seharusnya ada mention tentang:
- Index strategy (PRIMARY KEY on nim, INDEX on nama)
- Query optimization planning
- Rationale: mengapa perlu algoritma custom ketika MySQL sudah punya ORDER BY & WHERE
```

#### 2.4.8 Pengujian Black Box ‚úì
- Definisi jelas
- Equivalence Partitioning mentioned
- Benefits explained
- Referensi (Yulianti et al., 2023)

---

### 4. BAB III - METODOLOGI PENELITIAN ‚úì SANGAT DETAIL

#### 3.1 Tahapan Pelaksanaan Penelitian ‚úì SANGAT BAIK

**Penjelasan R&D + Waterfall:**
- Justifikasi metode jelas: orientasi produk, tahapan sistematis
- 5 tahapan Waterfall explained dengan detail:

**1. Requirements Analysis ‚úì**
- Identifikasi masalah: spreadsheet fragmented
- Keselarasan dengan R&D explained

**2. System Design ‚úì**
- Database structure, process flow, UI design
- Foundation untuk development

**3. Development ‚úì**
- Laravel + MySQL mentioned
- **Algoritma implementation mentioned explicitly**:
  > "penerapan algoritma Quick Sort untuk proses pengurutan data dan Binary Search untuk proses pencarian data"

‚úì Jelas bahwa algoritma akan diimplementasikan di application layer

**4. Testing ‚úì**
- Functional testing
- **Performance testing algoritma mentioned**
- Metrics: waktu eksekusi, respons sistem

**5. Maintenance ‚úì**
- Bug fixes
- Adaptasi kebutuhan future
- Alignment dengan R&D revision phase

**Referensi konsisten:** Susilawati et al., 2025

#### 3.2 Pengumpulan Data ‚úì BAIK

**3 Metode:**

**1. Studi Pustaka ‚úì**
- Sumber: buku, artikel, jurnal, dokumen
- Purpose: landasan teori, konsep algoritma, metode penelitian

**2. Observasi ‚úì**
- Direct observation pada proses praktikum
- Identifikasi pain points
- Understanding user needs

**3. Wawancara ‚úì**
- Narasumber: asisten praktikum
- Purpose: deep dive ke proses, ekspektasi sistem
- Qualitative data collection

**Catatan:** Kombinasi metode ini solid untuk requirement gathering.

#### 3.3 Perancangan Data ‚úì SANGAT BAIK (hal. 28-30)

**ERD Explanation:**
- Tujuan: terpusat, konsisten, efisien
- Approach: identify entities, attributes, relationships
- Benefits: reduce redundancy, maintain integrity, ease development
- Referensi (Pulungan et al., 2022)

**Entitas Dijelaskan dengan Detail:**

**1. Entitas Akun ‚úì**
- Atribut: id_akun (PK), email, nama, nim, prodi, jenis_kelamin, nomor_ponsel, password
- Role: pusat autentikasi
- Relasi: one-to-many ke Praktikan, Asisten, PJ

**2. Entitas Praktikan ‚úì**
- Atribut: id_praktikan (PK), tempat_lahir, tanggal_lahir, alamat, prestasi_mtq
- Proses: registrasi ‚Üí lengkapi profil
- Relasi: many-to-one ke Akun, Kelompok

**3. Entitas Asisten ‚úì**
- Atribut: id_asisten (PK), status, lulus_m3
- Relasi: many-to-many dengan Kelompok

**4. Entitas Kelompok ‚úì**
- Atribut: id_kelompok (PK), nama_kelompok
- Relasi: penghubung Praktikan, Asisten, Praktikum

**5. Entitas Praktikum ‚úì**
- Atribut: id_praktikum (PK), tahun_akademik, semester
- Relasi: one-to-many ke Kelompok
- Purpose: isolasi data antar periode

**6. Entitas PJ Praktikum ‚úì**
- Atribut: id_pj_praktikum (PK), status
- Role: supervisor, data recap
- Relasi: terhubung dengan Penilaian

**7. Entitas Penilaian ‚úì**
- Atribut: id_penilaian (PK), absensi, pretest_sholat, pretest_bbaq, posttest_sholat, posttest_wudhu, posttest_bbaq, posttest_janaiz, posttest_tertulis
- Relasi: many-to-one ke Praktikan, Asisten, PJ

**Gambar 3.3 ERD Sistem Praktikum PAI ‚úì**
- Visual diagram included
- Relasi jelas (one-to-many, many-to-many)
- Normalisasi tampak baik (no obvious redundancy)

**‚ö†Ô∏è MINOR - Saran untuk ERD:**
```
Tambahkan entitas untuk logging performa:
- logs_performance
  - id_log (PK)
  - operation_type (enum: 'sort', 'search')
  - algorithm_used (varchar)
  - dataset_size (int)
  - execution_time_ms (float)
  - memory_usage_mb (float)
  - timestamp (datetime)

Ini penting untuk evaluasi performa algoritma secara empiris.
```

#### 3.4 Perancangan Proses ‚úì SANGAT LENGKAP

**Penjelasan Umum (hal. 30-31):**
- Tujuan: structured, consistent, user-appropriate
- 3 modeling tools: Flowchart, DFD, Use Case
- Masing-masing punya peran berbeda

**3.4.1 Use Case Diagram ‚úì BAIK**

**Aktor Praktikan:**
- Use cases: registrasi, login, view/edit data diri, lihat materi, lihat presensi, lihat nilai pretest/posttest
- Flow explained: registrasi ‚Üí login ‚Üí access features

**Aktor Asisten:**
- Use cases: login, input presensi, penilaian pretest, penilaian posttest, akses data praktikan & materi
- Role: operational executor

**Aktor PJ Praktikum:**
- Use cases: login, manajemen periode, manajemen materi, manajemen praktikan, manajemen asisten, manajemen kelompok, manajemen pretest/posttest/presensi
- Role: full system administrator
- Purpose: monitoring & evaluasi menyeluruh

**Gambar 3.4.1 Use Case Sistem ‚úì**
- Visual diagram included
- Relationships clear (include, extend if any)
- System boundary defined

**3.4.2 DFD Level 0 ‚úì BAIK**

**Penjelasan:**
- Main process: Sistem Praktikum PAI
- External entities: PJ Praktikum, Asisten, Praktikan

**Data Flow Explained:**

**PJ Praktikum ‚Üî Sistem:**
- Input: data asisten, data PJ, data materi, data presensi, data pretest/posttest, data periode
- Output: rekap data praktikan, rekap nilai, rekap presensi
- Role: comprehensive data management

**Asisten ‚Üî Sistem:**
- Input: presensi praktikan, nilai pretest/posttest
- Output: info materi, info data praktikan
- Role: operational data entry

**Praktikan ‚Üî Sistem:**
- Input: registrasi, data diri
- Output: info materi, info presensi, info pretest/posttest
- Role: self-service information access

**Gambar 3.4.2 DFD Level 0 ‚úì**
- Visual diagram included
- Data flow arrows clear
- Process (lingkaran) sebagai pusat

**Catatan Positif:**
> "sistem berperan sebagai penghubung utama antara seluruh entitas eksternal dan basis data praktikum, sehingga aliran data dapat dikelola secara terstruktur, konsisten, dan terintegrasi tanpa ketergantungan pada proses manual"

‚úì Ini menunjukkan pemahaman tentang centralized system architecture

**3.4.3 Flowchart Sistem ‚úì**
- Penjelasan: dibagi per role (Praktikan, Asisten, PJ)
- Include: proses khusus (presensi, penilaian, manajemen data)
- **Include: algoritma (pengurutan, pencarian)**

‚úì Ini mengindikasikan flowchart algoritma akan ada (confirmed di halaman selanjutnya)

**3.4.4 Flowchart Praktikan ‚úì BAIK**

**Alur Explained:**
1. Akses website
2. Sistem tampilkan homepage
3. Decision: punya akun?
   - Ya ‚Üí login (email + password) ‚Üí validasi
     - Berhasil ‚Üí beranda ‚Üí menu (materi, data diri)
     - Gagal ‚Üí ulang login
   - Tidak ‚Üí halaman pendaftaran ‚Üí registrasi ‚Üí login
4. Beranda: access various menus
5. Logout

**Gambar 3.4.4 Flowchart Praktikan ‚úì**
- Visual flowchart with standard symbols
- Decision points (diamond) clear
- Flow logical

**3.4.5 Flowchart Asisten** (terpotong di hal. 36-37)
- Alur dimulai: akses website ‚Üí login ‚Üí validasi
- (Detail lengkap belum terlihat di excerpt ini)

---

### 5. TEMUAN BARU dari Halaman 26-50

#### ‚úÖ POSITIVE FINDINGS:

**1. Implementasi Algoritma Dijelaskan Kontekstual**
> "Controller bertugas... termasuk pemanggilan fungsi Quick Sort untuk pengurutan dan Binary Search untuk pencarian" (hal. 22)

‚úì Ini menjawab pertanyaan "Di mana algoritma diimplementasikan?" ‚Üí **Di Laravel Controller (application layer)**

**2. ERD Sangat Detail dan Well-Normalized**
- 7 entitas utama dengan relasi jelas
- No obvious redundancy
- Supports multi-period data isolation

**3. Metodologi R&D + Waterfall Justified dengan Baik**
- Alignment antara R&D phases dan Waterfall stages explained
- Konsisten reference ke Susilawati et al., 2025

**4. Data Collection Methods Comprehensive**
- Triangulation: studi pustaka, observasi, wawancara
- Qualitative + quantitative approach

**5. Perancangan Proses Sangat Lengkap**
- Use Case, DFD, Flowchart all present
- Multi-perspective modeling

#### ‚ö†Ô∏è ISSUES YANG MASIH ADA:

**1. Database Indexing Masih Belum Dibahas**
Meskipun MySQL dijelaskan, belum ada pembahasan tentang:
- Index strategy
- B-Tree structure
- Perbandingan query dengan index vs binary search manual

**2. Logging Mechanism untuk Performance Evaluation Tidak Explained**
ERD tidak include tabel logging untuk capture:
- Execution time
- Memory usage
- Dataset characteristics

**3. Flowchart Algoritma Belum Terlihat Lengkap**
Di halaman 26-50 ini:
- Flowchart Praktikan ‚úì (ada)
- Flowchart Asisten (partially, terpotong)
- Flowchart Quick Sort (disebutkan akan ada, tapi belum terlihat)
- Flowchart Binary Search (disebutkan akan ada, tapi belum terlihat)

Namun di daftar isi sebelumnya disebutkan:
- 3.4.9 Flowchart Proses Pencarian Binary Search (hal. 42)
- 3.4.10 Flowchart Quick Sort (hal. 45)
- 3.4.11 Flowchart Pemilihan Pivot MO7 (hal. 47)
- 3.4.12 Flowchart Partition Quick Sort (hal. 48)

‚úì Flowchart algoritma ADA, tapi ada di halaman selanjutnya (belum ter-audit)

**4. Detail Pengujian Performa Masih Belum Terlihat**
Di daftar isi:
- 3.7 Evaluasi Kinerja Algoritma (hal. 70-73)

Ini ADA tapi belum terlihat di excerpt hal. 26-50.

---

### 6. UPDATE PENILAIAN

| Aspek | Nilai Sebelumnya | Nilai Updated | Perubahan |
|-------|------------------|---------------|-----------|
| **BAB II - Teori Pendukung** | 8.5/10 | **8.5/10** | Tetap, sudah baik |
| **BAB III - Metodologi** | 7.5/10 | **8/10** | **+0.5** (ERD & process design sangat detail) |
| **Perancangan Sistem** | 9/10 | **9/10** | Tetap, excellent |

**NILAI KESELURUHAN UPDATE: 7.5 ‚Üí 7.7/10**

---

### 7. ACTION ITEMS UPDATE

#### ‚úÖ SUDAH DIPENUHI dari Rekomendasi Sebelumnya:

1. ‚úÖ **Teori Pendukung Lengkap**
   - Quick Sort dengan MO7 ‚úì
   - Binary Search ‚úì
   - Kombinasi keduanya ‚úì
   - Metodologi Waterfall ‚úì

2. ‚úÖ **ERD Detail dan Normalized**
   - 7 entitas dengan relasi jelas
   - Atribut explained satu per satu

3. ‚úÖ **Perancangan Proses Comprehensive**
   - Use Case ‚úì
   - DFD ‚úì
   - Flowchart ‚úì

4. ‚úÖ **Stack Teknologi Justified**
   - Setiap teknologi explained dengan konteks
   - Laravel MVC architecture explained dengan link ke algoritma

#### ‚ö†Ô∏è MASIH PERLU (Dari Rekomendasi Sebelumnya):

1. ‚ö†Ô∏è **Teori Database Indexing**
   - Masih belum ada sub-bab tentang B-Tree index
   - Belum ada comparison: database-level vs application-level operations

2. ‚ö†Ô∏è **Baseline Comparison**
   - Belum terlihat di hal. 26-50
   - Mungkin ada di section 3.7 Evaluasi Kinerja (hal. 70-73)

3. ‚ö†Ô∏è **Threat to Validity**
   - Belum terlihat

4. ‚ö†Ô∏è **Logging Mechanism untuk Performance Evaluation**
   - Perlu ditambahkan ke ERD

---

## L. KESIMPULAN SEMENTARA (Setelah Review Hal. 26-50)

### Kekuatan Tambahan yang Teridentifikasi:

1. **Konteks Implementasi Algoritma Jelas**
   - Laravel Controller sebagai tempat algoritma
   - Eloquent ORM untuk data fetching
   - Clear separation: DB untuk storage, Laravel untuk processing

2. **Database Design Sangat Matang**
   - ERD normalized
   - Atribut dijelaskan dengan reasoning
   - Relasi many-to-many handled dengan benar

3. **Metodologi Justified dengan Baik**
   - R&D alignment dengan Waterfall explained
   - Each phase purpose clear

### Kelemahan yang Masih Konsisten:

1. **Gap Database vs Application Processing Masih Ada**
   - Meskipun konteks Laravel explained, WHY not use SQL ORDER BY belum ter-address kuat

2. **Performance Evaluation Details Belum Terlihat**
   - Perlu tunggu review section 3.7 (hal. 70+)

### Rekomendasi Lanjutan:

**PRIORITY 1 (Masih Critical):**
1. Tambahkan sub-bab "2.2.8 Database Indexing dan Query Optimization"
2. Jelaskan trade-off: DB-level sorting vs app-level Quick Sort
3. Berikan use case konkret: kapan Quick Sort manual worth it

**PRIORITY 2 (Masih Important):**
4. Tambahkan tabel logging ke ERD untuk performance evaluation
5. Pastikan section 3.7 Evaluasi Kinerja detail (perlu review hal. 70+)

**PRIORITY 3 (Perbaikan Minor):**
6. Klarifikasi: vanilla JavaScript atau library (jQuery, etc.)?

---

**Status Audit Lanjutan:** DILANJUTKAN KE HALAMAN 51+
**Next Focus:** Flowchart Algoritma (Binary Search, Quick Sort, MO7, Partition) & Evaluasi Kinerja Algoritma

---

## D. ANALISIS HALAMAN 51-75 (LANJUTAN BAB 3)

### Analisis Sub-bab 3.4.5 - 3.4.12: Flowchart Sistem

#### 3.4.5 Flowchart Asisten ‚úì BAIK
**Kekuatan:**
- Alur login dengan validasi yang jelas
- Menggambarkan fitur-fitur Asisten: melihat materi, presensi, input nilai
- Fitur pencarian data Praktikan disebutkan

**‚ö†Ô∏è MINOR - Perlu Klarifikasi:**
```
Pada deskripsi disebutkan "sistem menyediakan fitur pencarian untuk
mempermudah proses pencarian data Praktikan"

PERTANYAAN:
- Di sinilah Binary Search akan diimplementasikan?
- Apakah pencarian ini real-time saat Asisten mengetik?
- Apakah data di-fetch dulu ke memory baru di-search, atau langsung SQL query?

REKOMENDASI: Tambahkan keterangan teknis di caption atau footnote
‚Üí "Fitur pencarian menggunakan Binary Search pada data yang telah
   diurutkan dengan Quick Sort"
```

#### 3.4.6 Flowchart PJ Praktikum ‚úì BAIK
**Kekuatan:**
- Alur manajemen data yang komprehensif
- Mengelola: kategori penilaian, materi, periode, Asisten, Praktikan, penilaian
- Struktur navigasi yang jelas

#### 3.4.7 Flowchart Proses Penilaian dan Presensi ‚úì BAIK
**Kekuatan:**
- Menggambarkan alur input nilai (keaktifan, pretest, posttest)
- Fitur pencarian data disebutkan kembali
- Alur yang logis dan terstruktur

**‚ö†Ô∏è CRITICAL - MISSING LINK KE ALGORITMA:**
```
Flowchart ini menyebutkan "fitur pencarian data" tapi TIDAK menunjukkan:
1. Kapan data diurutkan (Quick Sort)?
2. Kapan Binary Search dipanggil?
3. Apakah sorting terjadi setiap kali "Menampilkan daftar Praktikan"?

REKOMENDASI PERBAIKAN:
Tambahkan sub-proses di flowchart:
[Menampilkan daftar Praktikan]
    ‚Üì
[Proses Quick Sort - Mengurutkan kategori pencarian]
    ‚Üì
[Sistem menerima data array yang sudah terurut...]
    ‚Üì
[Proses pencarian] ‚Üí {Apakah Asisten ingin mencari praktikan?}
    Ya ‚Üí [Proses Binary Search (Lihat Flowchart 3.4.9)]
```

#### 3.4.8 Flowchart Proses Manajemen Data ‚úì BAIK
**Kekuatan:**
- Alur CRUD (Create, Read, Update) yang jelas
- Fitur pencarian untuk efisiensi pengelolaan
- Struktur yang sesuai untuk PJ Praktikum

#### 3.4.9 Flowchart Proses Pencarian Binary Search ‚úì‚úì SANGAT BAIK
**Kekuatan:**
- **Algoritma Binary Search diimplementasikan dengan BENAR**
- Langkah-langkah jelas:
  1. Sistem mendeteksi kategori pencarian
  2. **Data diurutkan terlebih dahulu (Proses Quick Sort)**
  3. Sistem menerima data array yang sudah terurut
  4. Sistem menentukan batas L (Left) dan R (Right)
  5. Evaluasi L ‚â§ R?
  6. Hitung Mid = (L + H)/2
  7. Bandingkan data tengah dengan key
  8. Geser batas (H = Mid-1 atau L = Mid+1)
- Struktur flowchart mengikuti pseudocode Binary Search dengan tepat

**Catatan Positif:**
> "Proses diawali dengan sistem mengenali kategori pencarian, kemudian data terlebih dahulu disiapkan dalam kondisi terurut..."

‚úì‚úì Ini menunjukkan mahasiswa MEMAHAMI bahwa Binary Search memerlukan **prerequisite data terurut**

**‚ö†Ô∏è MINOR - Potensi Perbaikan:**
```
TYPO di flowchart:
- Mid = (L + H)/2 ‚Üí seharusnya Mid = (L + R)/2
  (H biasanya notasi untuk "High", tapi di flowchart sebelumnya menggunakan R untuk "Right")

KONSISTENSI: Pilih satu notasi:
- L dan R (Left & Right) ‚Üí lebih umum di literatur
- atau L dan H (Low & High) ‚Üí juga valid

Pastikan konsisten di:
1. Flowchart
2. Pseudocode (jika ada di lampiran)
3. Source code implementasi
```

#### 3.4.10 Flowchart Quick Sort ‚úì‚úì SANGAT BAIK
**Kekuatan:**
- Struktur divide-and-conquer dijelaskan dengan baik
- Langkah-langkah:
  1. Sistem menerima data array
  2. Menentukan batas L (Low) dan H (High)
  3. Cek apakah L < H? (base case untuk rekursi)
  4. **Proses Pemilihan Pivot MO7** (sub-proses terpisah)
  5. **Proses Partitition** (sub-proses terpisah)
  6. Proses Quick Sort rekursif pada bagian kiri (L sampai pivot)
  7. Proses Quick Sort rekursif pada bagian kanan (pivot sampai H)
  8. Mengembalikan array yang sudah terurut

**Catatan Positif:**
- Modularitas baik: MO7 dan Partition dijadikan sub-proses terpisah
- Rekursi digambarkan dengan jelas
- Base case (L < H?) ada

#### 3.4.11 Flowchart Pemilihan Pivot MO7 ‚úì‚úì SANGAT BAIK
**Kekuatan:**
- **Implementasi Median of Seven dijelaskan dengan detail**
- Logika kondisional:
  - Jika data < 7 elemen ‚Üí pilih elemen tengah sebagai pivot (fallback sederhana)
  - Jika data ‚â• 7 elemen ‚Üí ambil 7 kandidat dari posisi:
    - L, H, (L+H)/2, (L+H)/3, (L+H)/6, 2(L+H)/3, 5(L+H)/6
- Menampilkan 7 nilai kandidat
- Menentukan median dari 7 nilai
- Nilai median dijadikan sebagai pivot

**‚ö†Ô∏è MINOR - Perlu Klarifikasi Matematis:**
```
Formula pemilihan 7 posisi kandidat:
L, H, (L+H)/2, (L+H)/3, (L+H)/6, 2(L+H)/3, 5(L+H)/6

PERTANYAAN:
1. Apakah ini sesuai dengan formula MO7 dari paper (Tahsin et al., 2024)?
2. Apakah ada risiko collision (dua posisi sama) pada array kecil?

REKOMENDASI:
Tambahkan referensi footnote:
"*Posisi kandidat pivot mengacu pada metode Tahsin et al. (2024),
 yang terbukti menghasilkan partisi lebih seimbang dibanding MO3/MO5"
```

**‚ö†Ô∏è MODERATE - Proses "Menentukan median dari 7 nilai":**
```
Flowchart hanya menyebutkan "Menentukan median dari 7 nilai tersebut"
tapi TIDAK menjelaskan BAGAIMANA median dihitung.

PERTANYAAN:
- Apakah 7 nilai diurutkan dulu (menggunakan algoritma sorting sederhana)?
- Apakah menggunakan selection algorithm?
- Apakah menggunakan hardcoded comparisons (optimal untuk n=7)?

REKOMENDASI:
Tambahkan sub-flowchart atau pseudocode:
"Proses Menentukan Median dari 7 Nilai:
 1. Sort 7 kandidat (bisa menggunakan sorting network atau insertion sort)
 2. Ambil nilai tengah (indeks ke-3 dari array terurut)"
```

#### 3.4.12 Flowchart Partition Quick Sort ‚úì BAIK
**Kekuatan:**
- Proses partisi Lomuto/Hoare dijelaskan
- Langkah-langkah:
  1. Sistem menerima data, pivot, L, H
  2. Sistem menetapkan posisi indeks i pada L
  3. Loop: Apakah data ke-i < pivot?
     - Ya ‚Üí Pindahkan ke kiri pivot
     - Tidak ‚Üí Data tetap di kanan
  4. Naikkan indeks i (i = i + 1)
  5. Ulangi sampai i ‚â§ H
  6. Sistem menempatkan pivot pada posisi yang benar
  7. Return posisi pivot

**‚ö†Ô∏è MODERATE - Implementasi Partition Scheme:**
```
Dari flowchart, terlihat menggunakan skema:
"Apakah data ke-i < pivot? ‚Üí Pindahkan ke sisi kiri pivot"

PERTANYAAN:
1. Apakah ini Lomuto partition scheme?
2. Apakah menggunakan two-pointer (Hoare scheme)?

REKOMENDASI:
Jelaskan di caption:
"Partition menggunakan Lomuto scheme dengan single pointer traversal,
 memisahkan elemen ‚â§ pivot ke sisi kiri dan > pivot ke sisi kanan"
```

---

### Analisis Sub-bab 3.5: Perancangan Tampilan (Wireframe)

#### Penjelasan Umum Perancangan Tampilan ‚úì BAIK
**Kekuatan:**
- Tujuan wireframe jelas: mudah digunakan, informatif, sesuai peran pengguna
- Berdasarkan hasil analisis kebutuhan sistem
- Pembagian peran: Praktikan, Asisten, PJ

#### 3.5.1 - 3.5.3 Halaman Autentikasi (Masuk, Daftar, Beranda) ‚úì BAIK
**Kekuatan:**
- Fitur login dengan email & password
- Fitur pemulihan kata sandi
- **Login dengan Google** (OAuth integration)
- Halaman daftar dengan validasi data lengkap
- Landing page sebagai entry point

**‚ö†Ô∏è MINOR - Security Consideration:**
```
Pada halaman Daftar, ada field:
- Password
- Ulangi Password

REKOMENDASI TAMBAHAN (untuk implementasi):
1. Password strength indicator
2. Validasi: minimal 8 karakter, kombinasi huruf-angka-simbol
3. Hash password dengan bcrypt/Argon2 sebelum disimpan ke database
4. CSRF protection untuk form submission

(Catatan: Ini implementasi detail, tidak perlu di proposal,
 tapi bagus jika disebutkan di sub-bab "Keamanan Sistem")
```

#### 3.5.4 - 3.5.6 Wireframe Praktikan ‚úì SANGAT BAIK
**Kekuatan:**
- Beranda menampilkan:
  - Nilai akhir
  - Persentase kehadiran (Pie Chart)
  - Rincian nilai (keaktifan, pretest, posttest)
  - Data Asisten dan kelompok
- Halaman Data Diri:
  - Dapat melihat dan memperbarui data
  - Upload/ganti file PDF prestasi MTQ
  - Informasi lengkap (data pribadi, kontak)
- Halaman Materi:
  - Daftar materi dari Google Drive
  - **Fitur pencarian materi**
  - Dapat ditampilkan langsung saat dipilih

**‚ö†Ô∏è MINOR - Fitur Pencarian Materi:**
```
Di wireframe Materi Praktikan (Gambar 3.5.6) ada field "Cari Materi"

PERTANYAAN:
- Apakah pencarian materi juga menggunakan Binary Search?
- Atau hanya fitur filter frontend sederhana?

REKOMENDASI:
Jika jumlah materi < 50, pencarian sederhana (linear/filter) sudah cukup.
Fokuskan Binary Search pada pencarian PRAKTIKAN (dataset 500-1000).
```

#### 3.5.7 - 3.5.11 Wireframe Asisten ‚úì SANGAT BAIK
**Kekuatan:**
- Beranda Asisten menampilkan:
  - Pie Chart Pertemuan
  - Data Asisten dan kelompok
  - Ringkasan: Rata-rata Pretest/Posttest, Jumlah Alpa
  - **Daftar Praktikan yang belum mengikuti Pretest/Posttest**
- Halaman Presensi:
  - **Fitur pencarian Praktikan** ‚Üê BINARY SEARCH DI SINI
  - **Sorting berdasarkan pertemuan**
  - Input kehadiran per pertemuan
- Halaman Penilaian Pretest/Posttest:
  - **Fitur pencarian Praktikan** ‚Üê BINARY SEARCH DI SINI JUGA
  - Input nilai per subjek penilaian
  - Tombol "Tampilkan Berdasarkan Test"
- Halaman Materi: Read-only (tidak bisa edit)

**‚úì‚úì CRITICAL INSIGHT - IMPLEMENTASI BINARY SEARCH JELAS:**
```
Dari wireframe, terlihat bahwa Binary Search akan digunakan pada:

1. PRESENSI (Gambar 3.5.8):
   - Field: "Cari Praktikan Berdasarkan Urutan Sekarang"
   - Action: "Saring Berdasarkan Pertemuan"
   ‚Üí Data praktikan diurutkan berdasarkan kriteria (NIM/Nama)
   ‚Üí Binary Search saat Asisten mengetik di search field

2. PENILAIAN PRETEST/POSTTEST (Gambar 3.5.10):
   - Field: "Cari Praktikan Berdasarkan Urutan Sekarang"
   - Action: "Tampilkan Berdasarkan Test"
   ‚Üí Data diurutkan berdasarkan NIM atau nama
   ‚Üí Binary Search untuk menemukan praktikan tertentu

INI MENJAWAB PERTANYAAN BESAR:
"Kapan Quick Sort dan Binary Search digunakan?"

JAWABAN:
- Quick Sort: Saat data praktikan ditampilkan (sorting berdasarkan NIM/Nama)
- Binary Search: Saat Asisten/PJ mencari praktikan spesifik di search field
```

#### 3.5.12 - 3.5.20 Wireframe PJ Praktikum ‚úì‚úì SANGAT KOMPREHENSIF
**Kekuatan:**
- Beranda PJ:
  - Pie Chart Persentase Kelulusan
  - Grafik BBAQ Ikhwan dan Akhwat
  - Ringkasan data praktikum
- Manajemen Periode:
  - Tambah/Edit periode (Tahun Akademik, Semester)
  - Melihat detail per periode
- Manajemen Kategori Penilaian:
  - Definisi subjek penilaian
  - Bobot nilai akhir
  - Tipe penilaian (Single/Multiple subject)
- Manajemen Materi:
  - CRUD materi praktikum
  - Link Google Drive materi
- Beranda Periode:
  - Pie Chart Perempuan/Laki-laki
  - Grafik BBAQ (Total, Ikhwan, Akhwat)
  - Grafik Kelulusan (Total, Ikhwan, Akhwat)
  - Ringkasan data periode
- Manajemen Asisten, Praktikan, Kelompok:
  - CRUD dengan **fitur pencarian dan sorting**
- Halaman Presensi Periode:
  - **Saring Berdasarkan Kelompok/Pertemuan**
  - Melihat kehadiran semua praktikan
- Halaman Nilai Akhir:
  - **Export nilai akhir** (Excel/PDF)
  - Rekap nilai seluruh praktikan

**‚úì‚úì EXCELLENT - DATA VISUALIZATION:**
```
PJ memiliki akses ke berbagai visualisasi data:
1. Pie Chart kelulusan
2. Grafik BBAQ (Baca, Bacaan Al-Quran?)
3. Grafik kelulusan berdasarkan gender

Ini menunjukkan sistem BUKAN hanya CRUD sederhana,
tapi memiliki fitur REPORTING dan ANALYTICS yang mature.
```

---

### Kesimpulan Analisis Halaman 51-75

#### Kekuatan yang Ditemukan:

1. **Flowchart Algoritma SANGAT DETAIL dan BENAR** ‚úì‚úì
   - Binary Search: Implementasi sesuai teori, prerequisite sorting dijelaskan
   - Quick Sort: Struktur rekursif, divide-and-conquer jelas
   - MO7: Pemilihan pivot dengan 7 kandidat explained
   - Partition: Proses pembagian data berdasarkan pivot clear

2. **Integrasi Algoritma ke Fitur Sistem JELAS** ‚úì‚úì
   - Dari wireframe terlihat bahwa Binary Search digunakan pada:
     - Halaman Presensi Asisten (search praktikan)
     - Halaman Penilaian Asisten (search praktikan)
     - Halaman Manajemen PJ (search asisten/praktikan/kelompok)
   - Quick Sort digunakan untuk:
     - Mengurutkan data praktikan sebelum ditampilkan
     - Sorting berdasarkan NIM, nama, atau kriteria lain
     - Menyiapkan data terurut sebagai input Binary Search

3. **Wireframe Komprehensif dan User-Centered** ‚úì
   - Pembagian peran (Praktikan, Asisten, PJ) jelas
   - Fitur sesuai kebutuhan masing-masing peran
   - UI/UX considerations: search, filter, sort, export

4. **Visualisasi Data dan Reporting** ‚úì
   - Pie chart, bar chart untuk analytics
   - Export nilai akhir untuk pelaporan
   - Dashboard informatif untuk decision making

#### Kelemahan yang Masih Ada:

1. **Detail Teknis Perhitungan Median MO7 Belum Dijelaskan** ‚ö†Ô∏è
   - Flowchart hanya menyebutkan "Menentukan median dari 7 nilai"
   - Tidak dijelaskan apakah 7 nilai diurutkan dulu atau menggunakan selection algorithm

2. **Partition Scheme Tidak Dispesifikasikan** ‚ö†Ô∏è
   - Apakah Lomuto atau Hoare partition?
   - Penting untuk dokumentasi dan implementasi

3. **Evaluasi Kinerja Algoritma Belum Terlihat** ‚ö†Ô∏è‚ö†Ô∏è
   - Di halaman 1-75, BELUM ada pembahasan tentang:
     - Metodologi pengujian kinerja
     - Variasi dataset (100, 500, 1000 entri)
     - Metrik evaluasi (waktu eksekusi, memory usage)
   - Ini adalah bagian CRITICAL dari rumusan masalah yang belum ter-address

4. **Typo Minor di Flowchart** ‚ö†Ô∏è
   - Mid = (L + H)/2 vs Mid = (L + R)/2 ‚Üí perlu konsistensi notasi

---

### Rekomendasi Prioritas untuk Halaman 51-75:

**PRIORITY 1 (Critical):**
1. ‚úì Flowchart algoritma sudah SANGAT BAIK - tidak perlu perubahan besar
2. ‚ö†Ô∏è Tambahkan sub-flowchart atau pseudocode untuk "Menentukan Median dari 7 Nilai"
3. ‚ö†Ô∏è Spesifikasikan partition scheme (Lomuto/Hoare) di caption

**PRIORITY 2 (Important):**
4. ‚ö†Ô∏è Perbaiki typo/inkonsistensi notasi (H vs R untuk Right/High)
5. ‚ö†Ô∏è Tambahkan keterangan teknis di wireframe yang memiliki fitur pencarian:
   ```
   "Fitur pencarian menggunakan algoritma Binary Search pada data
    yang telah diurutkan dengan Quick Sort MO7"
   ```

**PRIORITY 3 (Nice to Have):**
6. Tambahkan footnote/referensi di flowchart MO7 yang merujuk ke paper Tahsin et al. (2024)

---

**Status Audit Lanjutan:** PERLU REVIEW HALAMAN 76-94
**Next Critical Focus:**
- **SUB-BAB 3.7: EVALUASI KINERJA ALGORITMA** (ini adalah INTI dari penelitian)
- Metodologi pengujian
- Variasi dataset (100, 500, 1000 entri)
- Metrik: waktu eksekusi, memory usage, latensi sistem
- Perbandingan dengan metode baseline (SQL ORDER BY, SQL WHERE/LIKE)

---

## E. ANALISIS HALAMAN 76-94 (AKHIR BAB 3 + DAFTAR PUSTAKA)

### Analisis Sub-bab 3.6: Perancangan Pengujian

#### 3.6.1 - 3.6.7 Pengujian Fungsional (Black-Box Testing) ‚úì SANGAT BAIK

**Kekuatan:**
- **Comprehensive test coverage** untuk semua fitur sistem:
  - Login (3 role: Praktikan, Asisten, PJ)
  - Registrasi dengan validasi lengkap
  - Fitur Praktikan (beranda, data diri, materi)
  - Fitur Asisten (beranda, presensi, penilaian, materi)
  - Fitur PJ (beranda, periode, materi, kategori penilaian, manajemen data)
  - Navigasi dan kontrol umum
  - Hak akses (role-based access control)

**Catatan Positif:**
- Test cases sangat detail dan terstruktur
- Setiap test case memiliki:
  - Nama pengujian yang spesifik
  - Expected result yang jelas
  - Hasil pengujian (Sesuai)
- Validasi input comprehensive (email unik, NIM unik, password match, dll)
- Security testing included (hak akses, session management)

**‚ö†Ô∏è MINOR - Catatan Kecil:**
```
1. Semua hasil pengujian tercantum "Sesuai" ‚Üí ini berarti proposal ini
   dibuat SETELAH implementasi sudah berjalan?

   REKOMENDASI:
   Jika ini proposal (pre-implementation), seharusnya kolom "Hasil Pengujian"
   dikosongkan atau ditulis "Akan diuji setelah implementasi"

   Jika ini laporan (post-implementation), maka ini sudah tepat.

2. MISSING: Test case untuk fitur pencarian (Binary Search)

   Di Tabel 3.6.4 (Pengujian Fitur Asisten), ada:
   - "Cari materi" ‚Üí Materi tersaring (Sesuai)

   TAPI TIDAK ADA test case spesifik untuk:
   - "Cari Praktikan dengan Binary Search"
   - Verifikasi bahwa data diurutkan sebelum pencarian
   - Verifikasi hasil pencarian benar (ketemu / tidak ketemu)

   REKOMENDASI TAMBAHAN:
   Tambahkan test case spesifik untuk Binary Search:

   Tabel 3.6.X Pengujian Algoritma Binary Search
   | No | Bagian        | Nama Pengujian                  | Hasil yang Diharapkan                |
   |----|---------------|---------------------------------|--------------------------------------|
   | 1  | Binary Search | Cari praktikan yang ada         | Data ditemukan dan ditampilkan       |
   | 2  | Binary Search | Cari praktikan yang tidak ada   | Sistem menampilkan "Data tidak ada"  |
   | 3  | Binary Search | Data diurutkan sebelum search   | Data terurut berdasarkan kriteria    |
   | 4  | Binary Search | Search dengan keyword kosong    | Sistem menampilkan semua data        |
```

**‚ö†Ô∏è MODERATE - Missing: Pengujian Non-Fungsional**
```
Black-box testing sudah sangat baik untuk pengujian FUNGSIONAL,
tapi TIDAK ADA pengujian NON-FUNGSIONAL seperti:

1. Performance Testing
   - Response time untuk setiap operasi
   - Load testing (berapa banyak user concurrent yang bisa ditangani?)

2. Usability Testing
   - User experience assessment
   - Ease of use rating

3. Security Testing (lebih detail)
   - SQL Injection testing
   - XSS (Cross-Site Scripting) testing
   - CSRF testing

4. Compatibility Testing
   - Browser compatibility (Chrome, Firefox, Safari, Edge)
   - Responsive design testing (Desktop, Tablet, Mobile)

CATATAN:
Ini mungkin di luar scope proposal skripsi biasa, TAPI jika ingin
penelitian lebih komprehensif, bisa ditambahkan.
```

---

### Analisis Sub-bab 3.7: **Evaluasi Kinerja Algoritma** ‚úì‚úì SANGAT BAIK

**INI ADALAH BAGIAN PALING CRITICAL DARI SELURUH PROPOSAL**

#### 3.7.1 Objek Evaluasi ‚úì BAIK
**Kekuatan:**
- Objek evaluasi jelas: Quick Sort + Binary Search
- Konteks penggunaan jelas: pencarian dan pengelolaan data praktikan
- User context specified: khususnya asisten praktikum

#### 3.7.2 Parameter Evaluasi ‚úì‚úì SANGAT BAIK
**Kekuatan:**
- **3 parameter evaluasi yang TEPAT:**
  1. **Waktu eksekusi** (execution time)
  2. **Penggunaan memori** (memory usage)
  3. **Latensi respons sistem** (system response latency)

**Catatan Positif:**
‚úì‚úì Ini adalah parameter standar untuk evaluasi algoritma dalam konteks sistem berbasis web.

**‚ö†Ô∏è MINOR - Perlu Klarifikasi:**
```
Parameter "Latensi respons sistem" dijelaskan sebagai:
"waktu yang diperlukan sistem untuk memberikan respons terhadap
 permintaan pengguna hingga hasil pengolahan data ditampilkan
 pada antarmuka"

PERTANYAAN:
- Apakah ini termasuk network latency?
- Apakah ini termasuk rendering time di browser?
- Atau hanya server-side processing time?

REKOMENDASI:
Perjelas breakdown latensi:
- Network latency (client ‚Üí server ‚Üí client)
- Server processing time (Quick Sort + Binary Search + database query)
- Rendering time (browser menampilkan hasil)

Untuk evaluasi algoritma yang fair, fokus pada SERVER PROCESSING TIME saja.
```

**‚ö†Ô∏è CRITICAL - MISSING BASELINE COMPARISON:**
```
Parameter evaluasi sudah bagus, TAPI tidak disebutkan akan dibandingkan
dengan METODE BASELINE (metode alternatif).

Seperti yang disebutkan di Bab 1 (Latar Belakang):
"Pada konteks web application dengan database MySQL, sorting biasanya
 dilakukan di level database yang jauh lebih efisien"

PERTANYAAN PENTING:
Apakah akan ada perbandingan dengan:
1. SQL ORDER BY (untuk sorting)?
2. SQL WHERE/LIKE (untuk searching)?
3. Database indexing?

REKOMENDASI CRITICAL:
Tambahkan parameter evaluasi perbandingan:

Tabel Perbandingan Metode:
| Metode                          | Waktu Eksekusi | Memory Usage | Latensi |
|---------------------------------|----------------|--------------|---------|
| Quick Sort + Binary Search      | X ms           | Y MB         | Z ms    |
| SQL ORDER BY + WHERE/LIKE       | A ms           | B MB         | C ms    |
| Database Index (B-Tree)         | P ms           | Q MB         | R ms    |

Tanpa baseline comparison, SULIT untuk membuktikan bahwa Quick Sort + Binary
Search memang LEBIH BAIK atau LEBIH BURUK dari metode standar database.
```

#### 3.7.3 Dataset dan Variasi Ukuran Data ‚úì‚úì SANGAT BAIK
**Kekuatan:**
- **3 variasi dataset:** 100, 500, 1000 data praktikan ‚úì
- **Data source jelas:** database MySQL sistem praktikum ‚úì
- **Initial condition specified:** data dalam kondisi tidak terurut ‚úì

**Catatan Positif:**
‚úì Variasi dataset sesuai dengan rumusan masalah di Bab 1.
‚úì Kondisi data "tidak terurut" memastikan pengujian worst-case scenario.

**‚ö†Ô∏è MODERATE - Dataset Realism:**
```
Dataset 100, 500, 1000 sudah bagus untuk PROOF OF CONCEPT,
tapi di Latar Belakang disebutkan:

"Jumlah praktikan mencapai 500-700 per periode"

PERTANYAAN:
1. Apakah dataset 100 terlalu kecil untuk menunjukkan perbedaan performa?
2. Apakah dataset 1000 cukup untuk menunjukkan scalability?
3. Bagaimana jika di masa depan jumlah praktikan mencapai 2000?

REKOMENDASI:
Tambahkan 1-2 variasi dataset lebih besar untuk scalability testing:
- 2000 data (2x kondisi normal)
- 5000 data (stress testing)

Atau, jika infra tidak mendukung, jelaskan di batasan penelitian:
"Pengujian dibatasi hingga 1000 data karena keterbatasan server lokal"
```

#### 3.7.4 Skenario dan Prosedur Pengujian ‚úì BAIK
**Kekuatan:**
- **5 tahapan pengujian jelas:**
  1. Sistem berjalan di server lokal
  2. Data dipanggil dari database (sesuai variasi ukuran)
  3. Quick Sort dijalankan untuk mengurutkan
  4. Binary Search dijalankan untuk pencarian
  5. Metrik dicatat

- **Pengulangan: 10 kali per dataset** ‚Üí untuk stabilitas hasil ‚úì
- **Hasil dirata-ratakan** ‚Üí mengurangi bias ‚úì

**Catatan Positif:**
‚úì Prosedur scientific method yang baik (repetition + averaging)

**‚ö†Ô∏è MODERATE - Missing Details:**
```
Prosedur sudah baik, TAPI beberapa detail penting BELUM dijelaskan:

1. SORTING CRITERIA
   "Quick Sort dijalankan untuk mengurutkan data praktikan
    berdasarkan atribut tertentu"

   PERTANYAAN:
   - Atribut apa? NIM? Nama? Nilai?
   - Ascending atau descending?

   REKOMENDASI:
   Spesifikasikan: "Data diurutkan berdasarkan NIM (ascending)"

2. SEARCH TARGET
   "Binary Search dijalankan untuk melakukan pencarian data
    pada hasil pengurutan"

   PERTANYAAN:
   - Mencari apa? NIM spesifik? Nama?
   - Best case (data di tengah), Average case, atau Worst case (data di ujung)?

   REKOMENDASI:
   Jelaskan skenario pencarian:
   - Best case: Data di indeks tengah (mid-point)
   - Average case: Data di indeks acak
   - Worst case: Data di indeks pertama/terakhir

3. DATA STATE BETWEEN TESTS
   - Apakah data di-reset ke kondisi tidak terurut setiap kali pengujian?
   - Atau data tetap terurut dari pengujian sebelumnya?

   REKOMENDASI:
   Tambahkan: "Setiap pengulangan dimulai dengan data dalam kondisi
               tidak terurut (di-shuffle) untuk konsistensi pengujian"

4. WARM-UP RUNS
   - Apakah ada warm-up run (pengujian awal yang tidak dihitung)?
   - Ini penting untuk menghindari cold-start bias (JIT compilation, caching, dll)

   REKOMENDASI:
   Tambahkan: "Sebelum 10 kali pengulangan, dilakukan 2 kali warm-up run
               yang tidak dihitung untuk meminimalkan cold-start effect"
```

#### 3.7.5 Teknik Pengukuran ‚úì BAIK
**Kekuatan:**
- **Waktu eksekusi:** mencatat waktu sebelum & sesudah, hitung selisih ‚úì
- **Penggunaan memori:** konsumsi memori sistem during processing ‚úì
- **Latensi respons:** waktu permintaan ‚Üí hasil ditampilkan ‚úì
- **Averaging:** data dirata-ratakan untuk analisis ‚úì

**‚ö†Ô∏è CRITICAL - Missing Implementation Details:**
```
Teknik pengukuran dijelaskan secara KONSEPTUAL, tapi TIDAK SPESIFIK
bagaimana implementasinya.

PERTANYAAN PENTING:

1. WAKTU EKSEKUSI - Tool apa yang digunakan?
   - PHP: microtime(true)?
   - JavaScript: performance.now()?
   - Laravel: Benchmark::measure()?

   REKOMENDASI:
   Jelaskan: "Waktu eksekusi diukur menggunakan fungsi microtime(true)
             di PHP untuk mendapatkan presisi microsecond"

2. PENGGUNAAN MEMORI - Bagaimana cara mengukurnya?
   - PHP: memory_get_usage()?
   - memory_get_peak_usage()?
   - System monitoring tool (htop, Task Manager)?

   PERTANYAAN LEBIH DETAIL:
   - Apakah memory usage untuk seluruh proses atau hanya algoritma?
   - Apakah termasuk memory untuk data array?

   REKOMENDASI:
   Jelaskan: "Penggunaan memori diukur menggunakan memory_get_peak_usage()
             sebelum dan sesudah algoritma dijalankan"

3. LATENSI RESPONS - Bagaimana cara mengukurnya?
   - Frontend: performance.timing.loadEventEnd - navigationStart?
   - Backend: total execution time + rendering time?

   REKOMENDASI:
   Jelaskan: "Latensi respons diukur dari sisi client menggunakan
             Performance API JavaScript (performance.timing)"

4. DATA LOGGING
   - Bagaimana hasil pengukuran disimpan?
   - Apakah ada tabel database khusus untuk logging?
   - Atau ditulis ke file log?

   REKOMENDASI:
   Tambahkan: "Hasil pengukuran disimpan ke tabel 'performance_logs'
               dengan kolom: timestamp, dataset_size, sort_time,
               search_time, memory_usage, latency"
```

#### 3.7.6 Lingkungan Pengujian ‚ö†Ô∏è‚ö†Ô∏è CRITICAL ISSUE
**Masalah BESAR:**
```
Halaman 73 menyebutkan spesifikasi lingkungan pengujian,
tapi isinya COPY-PASTE dari tahapan pengujian (3.7.4)!

Ini adalah ERROR STRUKTURAL dalam proposal.

Yang SEHARUSNYA ada di bagian 3.7.6:

1. Server Specifications:
   - OS: Windows 10 / Ubuntu 20.04 / macOS
   - Processor: Intel Core i5/i7, RAM: 8GB/16GB
   - Storage: SSD/HDD

2. Software Stack:
   - Web Server: Apache 2.4 / Nginx
   - PHP: Versi 8.x
   - Laravel: Versi 10.x
   - MySQL: Versi 8.x
   - Browser: Chrome 120.x

3. Network Conditions:
   - Local server (no network latency)
   - Atau: LAN dengan latency <1ms

4. System Load:
   - No other applications running (clean environment)
   - Atau: Normal load (background apps allowed)

REKOMENDASI URGENT:
GANTI seluruh isi sub-bab 3.7.6 dengan spesifikasi lingkungan
pengujian yang SEBENARNYA.
```

#### 3.7.7 Analisis Hasil Evaluasi ‚úì CUKUP BAIK
**Kekuatan:**
- Metode analisis: **deskriptif kuantitatif** ‚úì
- Perbandingan nilai rata-rata pada setiap variasi dataset ‚úì
- Tujuan jelas: mengetahui kecenderungan perubahan kinerja ‚úì

**‚ö†Ô∏è MODERATE - Perlu Lebih Detail:**
```
Analisis dijelaskan secara umum, tapi TIDAK SPESIFIK tentang:

1. Metode Analisis Statistik
   - Apakah hanya membandingkan mean (rata-rata)?
   - Apakah ada analisis standar deviasi?
   - Apakah ada uji statistik (t-test, ANOVA)?

2. Visualisasi Data
   - Apakah akan ada grafik perbandingan?
   - Line chart untuk tren waktu eksekusi vs ukuran dataset?
   - Bar chart untuk perbandingan memory usage?

3. Interpretasi Hasil
   - Bagaimana menentukan apakah algoritma "efisien"?
   - Threshold apa yang digunakan? (e.g., < 100ms = fast, > 1s = slow)

REKOMENDASI:
Tambahkan:
"Hasil evaluasi akan divisualisasikan dalam bentuk:
 1. Tabel perbandingan nilai rata-rata per dataset
 2. Line chart untuk tren waktu eksekusi
 3. Bar chart untuk perbandingan memory usage

 Analisis akan mencakup:
 - Kompleksitas algoritma (O(n log n) untuk Quick Sort, O(log n) untuk Binary Search)
 - Perbandingan dengan kompleksitas teoritis
 - Identifikasi bottleneck (sorting vs searching vs database I/O)"
```

---

### Analisis Bagian 3.7 (Waktu dan Tempat Penelitian)

**‚ö†Ô∏è‚ö†Ô∏è CRITICAL - PLACEHOLDER TEXT:**
```
Halaman 74 masih berisi PLACEHOLDER:

"Penelitian ini akan dilaksanakan pada bulan ‚Ä¶‚Ä¶ sampai bulan ‚Ä¶‚Ä¶. tahun ‚Ä¶.."
"Adapun tempat pelaksanaan penelitian dilakukan di Instansi/Lembaga/Perusahaan
 ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶."
"sedangkan analisis data dilakukan pada Laboratorium ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶"

REKOMENDASI URGENT:
ISI dengan informasi sebenarnya:

Contoh:
"Penelitian ini akan dilaksanakan pada bulan Februari sampai bulan Mei tahun 2025.
 Adapun tempat pelaksanaan penelitian dilakukan di Unit Praktikum Pendidikan
 Agama Islam, Fakultas Teknik, Universitas Mulawarman, sedangkan analisis data
 dilakukan pada Laboratorium Rekayasa Perangkat Lunak, Program Studi Informatika,
 Fakultas Teknik, Universitas Mulawarman."
```

**‚ö†Ô∏è MINOR - Tabel Jadwal Penelitian:**
```
Tabel 3.x (seharusnya Tabel 3.8) Jadwal Penelitian sudah ADA,
tapi masih placeholder.

REKOMENDASI:
1. Ubah "Tabel 3.x" ‚Üí "Tabel 3.8"
2. Isi tahun di header tabel
3. Tandai bulan-bulan pelaksanaan dengan shading/checkmark
```

---

### Analisis Daftar Pustaka ‚úì‚úì SANGAT BAIK

**Kekuatan:**
- **Total referensi: 27** (memenuhi requirement 30-50) ‚úì
- **Tahun publikasi: 2020-2025** (5 tahun terakhir) ‚úì
- **Jurnal/prosiding:**
  - Ada jurnal internasional (European Modern Studies Journal, Procedia Computer Science)
  - Ada jurnal nasional terakreditasi
  - Ada prosiding konferensi (ICISET 2024)
- **Topik relevan:**
  - Quick Sort algorithm
  - Binary Search algorithm
  - Web-based information systems
  - Database design (ERD, DFD)
  - Software development methodology (Waterfall)
  - Performance evaluation

**Referensi Kunci yang SANGAT RELEVAN:**
1. **Tahsin et al. (2024)** - Median of Seven pivot selection ‚Üí CORE REFERENCE
2. **Meidiansyah et al. (2025)** - Comparative analysis Quick Sort + Binary Search
3. **Wang et al. (2024)** - Algorithm complexity theory
4. **Oladipupo et al. (2020)** - Quicksort vs Mergesort comparison

**‚ö†Ô∏è MODERATE - Missing Reference Types:**
```
Dari 27 referensi, SEMUA adalah artikel jurnal/prosiding.

Sesuai requirement:
- Artikel jurnal/prosiding: 60% ‚Üí SUDAH TERPENUHI (100%)
- Buku/Chapter Book: 30% ‚Üí TIDAK ADA (0%)
- Web: 10% ‚Üí TIDAK ADA (0%)

REKOMENDASI:
Tambahkan 8-13 referensi lagi untuk mencapai 30-50 total:

1. BUKU (8-10 referensi):
   - Cormen, T. H., et al. (2022). Introduction to Algorithms (4th ed.). MIT Press.
   - Sedgewick, R., & Wayne, K. (2021). Algorithms (4th ed.). Addison-Wesley.
   - Knuth, D. E. (2023). The Art of Computer Programming, Vol. 3: Sorting and Searching.
   - Date, C. J. (2020). Database Design and Relational Theory. O'Reilly.
   - Pressman, R. S., & Maxim, B. R. (2024). Software Engineering: A Practitioner's Approach (10th ed.).

2. WEB (2-3 referensi):
   - Laravel Documentation (https://laravel.com/docs)
   - PHP Manual - Sorting Functions (https://www.php.net/manual/en/array.sorting.php)
   - MySQL 8.0 Reference Manual - Optimization (https://dev.mysql.com/doc/refman/8.0/en/optimization.html)
```

**‚ö†Ô∏è MINOR - Formatting Issues:**
```
1. Ada duplikasi: Aleryani (2024a) dan Aleryani (2024b) ‚Üí SAMA PERSIS
   REKOMENDASI: Hapus salah satu

2. Smrti et al. (2023a) dan Smrti et al. (2023b) ‚Üí SAMA PERSIS
   REKOMENDASI: Hapus salah satu

3. Inconsistency: Ada yang menggunakan DOI, ada yang tidak
   REKOMENDASI: Pastikan semua referensi ada DOI (jika tersedia)
```

**‚ö†Ô∏è CRITICAL - Missing Highlight:**
```
Keterangan di halaman 78-79 (highlight kuning) menjelaskan requirement,
tapi TIDAK ADA analisis apakah proposal ini sudah memenuhi requirement.

REKOMENDASI:
Tambahkan tabel self-assessment:

| Requirement                     | Target | Actual | Status       |
|---------------------------------|--------|--------|--------------|
| Jurnal/prosiding (5 tahun)      | 60%    | 100%   | ‚úì Terpenuhi  |
| Buku (5 tahun)                  | 30%    | 0%     | ‚úó Kurang     |
| Web                             | 10%    | 0%     | ‚úó Kurang     |
| Total referensi                 | 30-50  | 27     | ‚ö†Ô∏è Hampir    |
| Software Management Reference   | Wajib  | Ya     | ‚úì Terpenuhi  |
```

---

### Kesimpulan Analisis Halaman 76-94

#### Kekuatan yang Ditemukan:

1. **Pengujian Fungsional SANGAT COMPREHENSIVE** ‚úì‚úì
   - Black-box testing untuk semua fitur
   - Test cases detail dengan expected results
   - Security testing (hak akses, validasi)

2. **Evaluasi Kinerja Algoritma WELL-STRUCTURED** ‚úì‚úì
   - Parameter evaluasi tepat (waktu, memori, latensi)
   - Variasi dataset sesuai scope (100, 500, 1000)
   - Prosedur pengujian scientific (repetition + averaging)

3. **Daftar Pustaka RELEVAN dan UP-TO-DATE** ‚úì
   - 27 referensi dari 2020-2025
   - Jurnal internasional dan nasional
   - Topik sangat relevan dengan penelitian

#### Kelemahan yang Masih Ada:

1. **CRITICAL - Sub-bab 3.7.6 (Lingkungan Pengujian) SALAH** ‚ö†Ô∏è‚ö†Ô∏è
   - Isi adalah copy-paste dari sub-bab 3.7.4
   - Harus diganti dengan spesifikasi server, software stack, network

2. **CRITICAL - Missing Baseline Comparison** ‚ö†Ô∏è‚ö†Ô∏è
   - Tidak ada perbandingan dengan SQL ORDER BY + WHERE/LIKE
   - Tidak ada perbandingan dengan database indexing
   - Sulit membuktikan Quick Sort + Binary Search lebih baik/buruk

3. **CRITICAL - Placeholder Text Belum Diisi** ‚ö†Ô∏è‚ö†Ô∏è
   - Waktu dan tempat penelitian (halaman 74)
   - Jadwal penelitian (Tabel 3.x)

4. **MODERATE - Missing Test Case untuk Binary Search** ‚ö†Ô∏è
   - Tidak ada test case spesifik untuk algoritma Binary Search
   - Test case hanya untuk fitur umum "cari materi/praktikan"

5. **MODERATE - Daftar Pustaka Kurang Diversifikasi** ‚ö†Ô∏è
   - 100% artikel jurnal, 0% buku, 0% web
   - Requirement: 60% jurnal, 30% buku, 10% web

6. **MODERATE - Implementation Details Kurang Spesifik** ‚ö†Ô∏è
   - Teknik pengukuran (microtime? performance.now?)
   - Data logging (database? file?)
   - Sorting criteria (NIM? Nama?)
   - Search target (best/average/worst case?)

7. **MINOR - Duplikasi Referensi** ‚ö†Ô∏è
   - Aleryani (2024a) = Aleryani (2024b)
   - Smrti et al. (2023a) = Smrti et al. (2023b)

---

### Rekomendasi Prioritas untuk Halaman 76-94:

**PRIORITY 1 (URGENT - MUST FIX):**
1. ‚ö†Ô∏è‚ö†Ô∏è **FIX Sub-bab 3.7.6** - Ganti dengan spesifikasi lingkungan pengujian SEBENARNYA
2. ‚ö†Ô∏è‚ö†Ô∏è **ISI Placeholder** - Waktu, tempat, dan jadwal penelitian
3. ‚ö†Ô∏è‚ö†Ô∏è **TAMBAH Baseline Comparison** - Bandingkan dengan SQL ORDER BY + WHERE/LIKE

**PRIORITY 2 (Important - SHOULD FIX):**
4. ‚ö†Ô∏è **TAMBAH Test Case Binary Search** - Test case spesifik untuk algoritma
5. ‚ö†Ô∏è **DIVERSIFIKASI Daftar Pustaka** - Tambah 8-10 buku + 2-3 web references
6. ‚ö†Ô∏è **DETAILKAN Teknik Pengukuran** - Spesifikasi tool/fungsi yang digunakan

**PRIORITY 3 (Nice to Have):**
7. Hapus duplikasi referensi (Aleryani, Smrti)
8. Tambahkan skenario pencarian (best/average/worst case)
9. Tambahkan warm-up runs dalam prosedur pengujian
10. Tambahkan visualisasi data (grafik) dalam analisis hasil

---

**Status Audit:** ‚úì‚úì SELESAI (Halaman 1-94 Sudah Diaudit Lengkap)
**Penilaian Keseluruhan Proposal:** 8.0/10
