# BAB I
# PENDAHULUAN

## 1.1 Latar Belakang

Peternakan ayam kontes memerlukan monitoring kondisi lingkungan kandang yang intensif, terutama suhu dan kelembaban yang harus dijaga dalam rentang optimal 28-32°C dan 60-70% RH. Kegagalan dalam menjaga kondisi optimal dapat menyebabkan stres pada ayam dan penurunan kualitas, yang berakibat pada kerugian ekonomi bagi peternak.

Teknologi Internet of Things (IoT) telah membuka peluang untuk monitoring kandang secara real-time menggunakan sensor. Beberapa penelitian seperti Hamzah et al. (2024) dan Suryanto & Ariefin (2024) telah mengembangkan sistem monitoring berbasis IoT. Namun, sistem-sistem tersebut memiliki keterbatasan dari perspektif informatika: (1) **data sensor tidak tersimpan dalam database terstruktur**, (2) **tidak ada visualisasi data historis** untuk analisis trend, dan (3) **tidak ada fitur prediksi** untuk membantu peternak mengantisipasi perubahan kondisi.

Sebagian besar sistem yang ada hanya menampilkan data real-time tanpa menyimpan data historis dalam database yang terstruktur. Peternak tidak dapat melihat pola suhu dan kelembaban dari waktu ke waktu, tidak dapat membandingkan kondisi hari ini dengan hari-hari sebelumnya, dan tidak mendapat informasi prediktif untuk perencanaan. Hal ini menyebabkan peternak hanya dapat **bereaksi terhadap masalah yang sudah terjadi**, bukan **mengantisipasi dan mencegahnya**.

Dari perspektif **sistem informasi**, diperlukan sistem yang dapat:
1. **Menyimpan data sensor** dalam database terstruktur untuk analisis jangka panjang
2. **Menampilkan visualisasi data** (grafik, chart) yang mudah dipahami peternak
3. **Memberikan prediksi sederhana** suhu beberapa jam ke depan untuk perencanaan

Oleh karena itu, penelitian ini bertujuan mengembangkan **Sistem Informasi Monitoring Kandang Ayam Kontes Berbasis IoT dengan Visualisasi Data dan Prediksi Suhu**. Sistem ini terdiri dari:
- **Database** untuk penyimpanan data sensor historis (MySQL)
- **Backend API** untuk CRUD data dan business logic (Node.js)
- **Dashboard web** dengan visualisasi interaktif (React.js + Chart.js)
- **Model prediksi sederhana** untuk forecasting suhu 6-12 jam ke depan

Kontribusi utama penelitian ini adalah pada aspek **informatika**: (1) desain database yang efisien untuk data time series, (2) dashboard web dengan visualisasi yang informatif untuk decision support, dan (3) implementasi prediksi suhu sederhana menggunakan teknik time series forecasting.

---

## 1.2 Rumusan Masalah

Berdasarkan latar belakang, rumusan masalah penelitian ini adalah:

1. Bagaimana merancang **database** yang efisien untuk menyimpan data sensor time series dalam jangka panjang?

2. Bagaimana membangun **web application** dengan visualisasi data interaktif untuk monitoring real-time dan analisis historis?

3. Bagaimana mengimplementasikan **prediksi suhu** sederhana untuk 6-12 jam ke depan menggunakan teknik time series forecasting?

4. Bagaimana menguji **performa dan usability** sistem dari sisi response time dan kemudahan penggunaan?

---

## 1.3 Batasan Masalah

Agar penelitian lebih fokus, ditetapkan batasan:

1. **Skala Sistem:**
   - Sistem untuk 1 kandang (single-kandang monitoring)
   - Data retention: 3 bulan di database

2. **Parameter Monitoring:**
   - Suhu (°C)
   - Kelembaban (% RH)
   - Status pakan (tersedia/habis)
   - Sampling: 5 menit sekali

3. **Database:**
   - DBMS: MySQL
   - Desain: 3 tabel (kandang, sensor_data, user)
   - ERD sederhana dengan normalisasi dasar

4. **Web Dashboard:**
   - Platform: Web application (desktop browser)
   - Framework: React.js
   - Visualisasi: 4 jenis (gauge chart, line chart, bar chart, data table)
   - User: Single user (tidak ada login/autentikasi di fase awal)

5. **Backend API:**
   - Framework: Node.js + Express.js
   - Endpoints: 8-10 endpoint CRUD dasar
   - Format data: JSON

6. **Prediksi Suhu:**
   - Metode: Moving Average atau Exponential Smoothing (metode statistik sederhana)
   - Horizon prediksi: 6-12 jam ke depan
   - Evaluasi: MAE (Mean Absolute Error), target < 2.5°C

7. **Hardware (Secondary):**
   - ESP32 + DHT22 (suhu & kelembaban)
   - Data dikirim via WiFi ke server
   - Detail hardware tidak menjadi fokus pembahasan

8. **Testing:**
   - Unit testing untuk API endpoints kritis (min 5 test cases)
   - Manual testing untuk dashboard UI
   - Performance testing sederhana (response time < 3 detik)
   - User testing dengan peternak (kuesioner sederhana)

9. **Yang Tidak Dikembangkan:**
   - Mobile application
   - Multi-user authentication
   - Real-time notification (push notification)
   - Control aktuator otomatis (hanya monitoring)
   - Machine learning kompleks (LSTM/deep learning)

---

## 1.4 Tujuan Penelitian

Tujuan penelitian ini adalah:

1. Merancang dan mengimplementasikan **database relasional** dengan ERD terstruktur untuk penyimpanan data sensor time series.

2. Membangun **web application** dengan 4 jenis visualisasi data (gauge chart, line chart, bar chart, table) untuk monitoring real-time dan analisis historis.

3. Mengimplementasikan **model prediksi suhu sederhana** menggunakan teknik statistik (Moving Average/Exponential Smoothing) dengan target akurasi MAE < 2.5°C.

4. Menguji **performa sistem** dari sisi response time API (target < 3 detik) dan usability dashboard melalui user testing dengan peternak.

---

## 1.5 Manfaat Penelitian

### 1.5.1 Manfaat Praktis

**Bagi Peternak:**
- Dapat melihat data historis suhu dan kelembaban dalam bentuk grafik yang mudah dipahami
- Mendapat informasi prediksi suhu untuk 6-12 jam ke depan sebagai early warning
- Dapat membandingkan kondisi hari ini dengan hari-hari sebelumnya
- Data tersimpan dan dapat diakses kapan saja untuk evaluasi

**Bagi Industri Smart Farming:**
- Contoh implementasi sistem informasi sederhana namun efektif untuk monitoring peternakan
- Blueprint database design untuk data sensor time series
- Referensi web dashboard untuk visualisasi data pertanian

### 1.5.2 Manfaat Akademis

**Kontribusi untuk Bidang Informatika:**

1. **Database Design untuk Time Series:**
   - Skema database efisien untuk data sensor dengan sampling rate tinggi
   - Teknik indexing untuk query performance pada data time series
   - Strategi data retention dan archiving

2. **Web Dashboard untuk IoT:**
   - Pattern visualisasi data time series yang informatif
   - Best practice integrasi Chart.js dengan React untuk real-time update
   - UI/UX design untuk dashboard monitoring

3. **Prediksi Sederhana yang Aplikatif:**
   - Implementasi prediksi time series dengan metode statistik sederhana
   - Perbandingan akurasi moving average vs exponential smoothing
   - Studi kasus penerapan forecasting untuk data sensor suhu

4. **Dataset Sensor Kandang:**
   - Dataset sensor suhu & kelembaban kandang ayam selama 2-3 bulan
   - Data dalam format CSV dengan timestamp, siap untuk penelitian lanjutan
   - Dapat digunakan untuk studi time series forecasting atau machine learning

**Bagi Mahasiswa:**
- Contoh skripsi informatika yang fokus ke sistem informasi dan data
- Referensi implementasi full-stack development (database, backend, frontend)
- Template untuk penelitian IoT yang menekankan aspek software

---

## 1.6 Sistematika Penulisan

**BAB I PENDAHULUAN**

Berisi latar belakang masalah dari perspektif informatika, rumusan masalah yang fokus pada database dan web development, batasan masalah yang realistis, tujuan penelitian yang terukur, dan manfaat penelitian dengan kontribusi informatika yang jelas.

**BAB II TINJAUAN PUSTAKA**

Membahas penelitian terdahulu tentang sistem monitoring IoT dengan analisis gap informatika, landasan teori meliputi: Database Management System (MySQL, ERD, normalisasi), Web Development (Node.js, React.js, REST API), Data Visualization (Chart.js), Time Series Forecasting (Moving Average, Exponential Smoothing), dan ringkasan singkat komponen hardware IoT.

**BAB III METODOLOGI PENELITIAN**

Menjelaskan metode pengembangan sistem menggunakan model waterfall (sederhana), tahapan penelitian (requirement, design, implementation, testing), perancangan database (ERD 3 tabel, SQL script), perancangan API (8-10 endpoints), perancangan UI dashboard (wireframe), desain prediksi suhu (moving average/exponential smoothing), dan rencana pengujian sistem.

**BAB IV PERANCANGAN SISTEM** (akan dibuat saat implementasi)

Berisi detail perancangan database, API specification, mockup UI dashboard, dan algoritma prediksi.

**BAB V IMPLEMENTASI DAN PENGUJIAN** (akan dibuat saat implementasi)

Menjelaskan proses implementasi sistem, hasil pengujian (unit test, performance test, user test), dan pembahasan hasil.

**BAB VI PENUTUP** (akan dibuat saat implementasi)

Berisi kesimpulan, keterbatasan sistem, dan saran pengembangan.

---

**CATATAN PENTING:**

Proposal ini dirancang agar:
- ✅ **Realistis** dikerjakan mahasiswa S1 dalam 6-8 bulan
- ✅ **Tetap fokus Informatika** (database + web app + visualisasi + prediksi sederhana)
- ✅ **Tidak terlalu kompleks** (tidak perlu LSTM, tidak perlu CI/CD, tidak perlu microservices)
- ✅ **Ada nilai akademis** (database design, visualisasi data, prediksi time series)
- ✅ **Feasible** dengan skill dasar: MySQL, Node.js, React.js, JavaScript basic

**Deliverables Utama:**
1. Database MySQL + ERD
2. Backend API (Node.js)
3. Frontend Dashboard (React.js + Chart.js)
4. Prediksi suhu sederhana (moving average/exponential smoothing)
5. Dataset CSV (3 bulan data sensor)
6. Laporan testing

# BAB II
# TINJAUAN PUSTAKA

## 2.1 Penelitian Terdahulu

### 2.1.1 Analisis Penelitian Terkait

**Tabel 2.1** Ringkasan Penelitian Terdahulu

| No | Peneliti & Tahun | Judul | Fokus | Gap yang Diisi Penelitian Ini |
|----|------------------|-------|-------|-------------------------------|
| 1 | Hamzah et al. (2024) | Integrasi Sistem Otomatis Kandang (Suhu, Pakan, PLTS) | Hardware automation | ❌ Tidak ada database terstruktur<br>❌ Tidak ada visualisasi historis<br>❌ Tidak ada prediksi |
| 2 | Suryanto & Ariefin (2024) | Monitoring Suhu dan Kelembaban IoT | Monitoring real-time | ❌ Data tidak tersimpan sistematis<br>❌ Tidak ada analisis trend<br>❌ Tidak ada prediksi |
| 3 | Musyahar et al. (2025) | Otomasi Dispenser Pakan dengan PLTS | Hardware (pakan + PLTS) | ❌ Tidak ada sistem informasi<br>❌ Tidak ada dashboard web<br>❌ Hanya monitoring dasar |

**Gap Informatika yang Teridentifikasi:**

1. **Database Management:** Tidak ada penelitian yang merancang database terstruktur untuk penyimpanan jangka panjang.
2. **Visualisasi Data:** Visualisasi terbatas pada real-time monitoring, tidak ada historical analytics.
3. **Prediksi:** Tidak ada penelitian yang mengimplementasikan prediksi suhu untuk early warning.
4. **Web Dashboard:** Tidak ada dashboard web yang user-friendly dengan multiple chart types.

### 2.1.2 Posisi Penelitian Ini

Penelitian ini mengisi gap dengan:
- ✅ Database MySQL terstruktur dengan ERD dan normalisasi
- ✅ Web dashboard dengan 4 jenis visualisasi (gauge, line chart, bar chart, table)
- ✅ Prediksi suhu sederhana menggunakan Moving Average
- ✅ Export data untuk analisis lanjutan

---

## 2.2 Internet of Things (IoT)

### 2.2.1 Definisi IoT

Internet of Things (IoT) adalah konsep di mana objek fisik terhubung ke internet untuk bertukar data secara otomatis. Dalam konteks smart farming, sensor di kandang dapat mengirim data suhu dan kelembaban ke cloud untuk monitoring dan analisis.

### 2.2.2 Arsitektur IoT untuk Smart Farming

**Gambar 2.1** Arsitektur IoT Sederhana

```
┌─────────────────────────────────────┐
│  LAYER 3: Application               │
│  (Web Dashboard - React.js)         │
└─────────────┬───────────────────────┘
              │ HTTP/REST API
┌─────────────▼───────────────────────┐
│  LAYER 2: Middleware                │
│  (Backend API + Database)           │
└─────────────┬───────────────────────┘
              │ MQTT Protocol
┌─────────────▼───────────────────────┐
│  LAYER 1: Sensor/Device             │
│  (ESP32 + DHT22)                    │
└─────────────────────────────────────┘
```

**Penelitian ini fokus pada Layer 2 & 3** (software), sementara Layer 1 (hardware) hanya sebagai data source.

### 2.2.3 Protokol MQTT

MQTT (Message Queuing Telemetry Transport) adalah protokol lightweight untuk komunikasi IoT dengan pola publish-subscribe:
- ESP32 **publish** data sensor ke broker
- Backend **subscribe** topic dan simpan data ke database
- Keuntungan: Efisien, real-time, reliable

---

## 2.3 Database Management System

### 2.3.1 Database Relasional (MySQL)

Database relasional menyimpan data dalam tabel dengan baris dan kolom. MySQL dipilih karena:
- Open-source dan gratis
- Mudah dipelajari
- Support untuk indexing (penting untuk query time series data)
- Kompatibel dengan Node.js

### 2.3.2 Entity Relationship Diagram (ERD)

ERD adalah diagram yang menggambarkan entitas, atribut, dan relasi dalam database. Komponen ERD:
- **Entity:** Objek (contoh: Kandang, SensorData)
- **Attribute:** Properti (contoh: suhu, kelembaban)
- **Relationship:** Hubungan antar entitas (one-to-many, many-to-many)

### 2.3.3 Normalisasi Database

Normalisasi adalah proses mengurangi redundansi data. Bentuk normal:
- **1NF:** Setiap cell atomic (tidak ada multiple values)
- **2NF:** Tidak ada partial dependency
- **3NF:** Tidak ada transitive dependency

Penelitian ini menerapkan normalisasi hingga 3NF.

### 2.3.4 Indexing untuk Performance

Index mempercepat query dengan membuat struktur data tambahan. Untuk time series data:

```sql
CREATE INDEX idx_timestamp ON tb_sensor_data(timestamp);
```

Index pada kolom `timestamp` membuat query "data 7 hari terakhir" jauh lebih cepat.

---

## 2.4 Web Application Development

### 2.4.1 Arsitektur Client-Server

Aplikasi web terdiri dari:
- **Client (Frontend):** React.js - menampilkan UI di browser
- **Server (Backend):** Node.js + Express - menyediakan API dan business logic
- **Database:** MySQL - menyimpan data

Keuntungan pemisahan:
- Frontend dan Backend dapat dikembangkan terpisah
- Scalable (dapat di-deploy di server berbeda)
- Maintainable (perubahan UI tidak affect backend)

### 2.4.2 REST API

REST (Representational State Transfer) adalah architectural style untuk API dengan prinsip:
- **Stateless:** Setiap request independen
- **Resource-based:** Setiap resource punya URI (contoh: `/api/sensor`)
- **HTTP Methods:** GET (read), POST (create), DELETE (delete)
- **JSON Format:** Data dikirim dalam format JSON

Contoh endpoint:
```
GET  /api/sensor/latest     → Ambil data sensor terbaru
GET  /api/sensor/history    → Ambil data historis
POST /api/sensor            → Insert data baru
```

### 2.4.3 React.js

React.js adalah JavaScript library untuk membangun UI dengan konsep component-based. Keuntungan:
- **Component reusable:** Gauge chart bisa dipakai ulang
- **Virtual DOM:** Performance tinggi
- **Large ecosystem:** Banyak library pendukung (Chart.js, React Router)

### 2.4.4 Node.js + Express.js

**Node.js** adalah JavaScript runtime untuk server-side. Keuntungan:
- JavaScript di frontend dan backend (single language)
- Asynchronous I/O (efisien untuk handling concurrent requests)
- NPM ecosystem (banyak package)

**Express.js** adalah web framework minimal untuk Node.js yang menyediakan routing dan middleware.

---

## 2.5 Data Visualization

### 2.5.1 Prinsip Visualisasi Data

Visualisasi data mengubah angka menjadi grafik agar mudah dipahami. Prinsip:
- **Clarity:** Grafik harus mudah dipahami
- **Accuracy:** Tidak misleading
- **Efficiency:** Menyampaikan informasi dengan cepat

### 2.5.2 Chart.js

Chart.js adalah JavaScript library untuk membuat chart interaktif. Keunggulan:
- Open-source dan gratis
- Simple API (mudah digunakan)
- Responsive (mobile-friendly)
- Support 8+ chart types

**Jenis Chart untuk Penelitian Ini:**

1. **Gauge Chart:** Untuk real-time value (suhu & kelembaban saat ini)
2. **Line Chart:** Untuk time series data (trend suhu 7 hari)
3. **Bar Chart:** Untuk comparison (rata-rata suhu per hari)
4. **Table:** Untuk raw data dengan pagination

---

## 2.6 Time Series Forecasting

### 2.6.1 Definisi Time Series

Time series adalah data yang diindex berdasarkan waktu. Contoh: suhu kandang setiap 5 menit. Karakteristik:
- **Trend:** Pola naik/turun jangka panjang
- **Seasonality:** Pola berulang (siang lebih panas dari malam)
- **Noise:** Random fluctuation

### 2.6.2 Moving Average (MA)

Moving Average adalah teknik prediksi sederhana dengan merata-ratakan nilai beberapa periode sebelumnya.

**Formula:**

```
MA(t) = (X(t-1) + X(t-2) + ... + X(t-n)) / n
```

Di mana:
- MA(t) = prediksi untuk waktu t
- X(t-i) = nilai aktual pada waktu t-i
- n = window size (jumlah data points)

**Contoh:**

Jika suhu 6 jam terakhir: [30.5, 30.3, 30.7, 30.9, 31.2, 31.0]

Prediksi suhu 1 jam ke depan:
```
MA = (30.5 + 30.3 + 30.7 + 30.9 + 31.2 + 31.0) / 6 = 30.77°C
```

**Keuntungan:**
- Sangat sederhana (mudah diimplementasi)
- Tidak perlu training (langsung pakai)
- Cepat (computational cost rendah)
- Cocok untuk data dengan trend yang stabil

**Keterbatasan:**
- Hanya bisa capture trend linear
- Tidak bisa capture seasonality kompleks
- Lag (delay) mengikuti perubahan tiba-tiba

### 2.6.3 Exponential Smoothing (Alternatif)

Exponential Smoothing memberikan bobot lebih besar pada data terbaru:

```
ES(t) = α × X(t-1) + (1-α) × ES(t-1)
```

Di mana α (alpha) = smoothing factor (0-1)

**Keuntungan dibanding MA:**
- Lebih responsif terhadap perubahan terbaru
- Hanya perlu 1 parameter (α)

**Penelitian ini akan membandingkan MA vs ES** dan pilih yang lebih akurat.

### 2.6.4 Evaluasi Model: MAE

Mean Absolute Error (MAE) mengukur rata-rata error prediksi:

```
MAE = (1/n) × Σ|Actual - Predicted|
```

Interpretasi:
- MAE = 2.0°C → rata-rata error prediksi adalah 2 derajat
- MAE lebih kecil = model lebih akurat

**Target penelitian ini:** MAE < 2.5°C

---

## 2.7 Software Development Methodology

### 2.7.1 Model Waterfall

Waterfall adalah model sequential dengan tahapan:
1. Requirements Analysis
2. System Design
3. Implementation
4. Testing
5. Deployment & Maintenance

**Keuntungan:**
- Sederhana dan mudah dipahami
- Cocok untuk project dengan requirements jelas
- Mudah didokumentasikan (cocok untuk skripsi)

**Kapan Digunakan:**
- Requirements sudah jelas dari awal
- Tidak banyak perubahan di tengah jalan
- Project kecil-menengah (seperti skripsi)

Penelitian ini menggunakan waterfall karena requirements sudah jelas: monitoring + visualisasi + prediksi.

---

## 2.8 Software Testing

### 2.8.1 Unit Testing

Unit testing menguji individual function/method secara isolated. Framework: **Jest** (untuk JavaScript/Node.js)

Contoh test case:
```javascript
test('GET /api/sensor/latest should return status 200', async () => {
  const response = await request(app).get('/api/sensor/latest');
  expect(response.status).toBe(200);
});
```

### 2.8.2 Performance Testing

Performance testing menguji response time sistem. Metrik:
- **Response Time:** Waktu dari request hingga response (target: < 3 detik)
- **Throughput:** Jumlah request per detik yang bisa dihandle

Tools: Postman (manual testing), curl (command line)

### 2.8.3 User Testing

User testing menguji apakah sistem mudah digunakan. Metode:
- Task-based testing (user diminta complete tasks)
- Kuesioner (5-10 pertanyaan, skala 1-5)
- Interview (tanya feedback & saran)

---

## 2.9 Komponen Hardware (Ringkasan)

**Catatan:** Hardware bukan fokus utama penelitian ini. Berikut ringkasan singkat.

**Tabel 2.2** Komponen Hardware

| Komponen | Fungsi | Spesifikasi |
|----------|--------|-------------|
| **ESP32** | Mikrokontroler IoT dengan WiFi built-in | 32-bit dual-core, WiFi 802.11 b/g/n |
| **DHT22** | Sensor suhu & kelembaban digital | Range: -40~80°C, 0-100% RH<br>Akurasi: ±0.5°C, ±2% RH |
| **Breadboard & Kabel** | Untuk wiring sensor | Standard breadboard |

**Komunikasi Data:**

```
ESP32 → WiFi → MQTT Broker → Backend (Node.js) → Database (MySQL)
```

**Data Format (JSON via MQTT):**

```json
{
  "device_id": "ESP32_001",
  "timestamp": "2026-01-14T10:30:00Z",
  "suhu": 30.5,
  "kelembaban": 65.2
}
```

**Catatan Penting:**
- Detail teknis hardware (wiring diagram, rangkaian elektronik) **TIDAK DIBAHAS** dalam proposal karena bukan fokus Informatika.
- Hardware hanya sebagai **data source** untuk sistem informasi.

---

## 2.10 Rangkuman Tinjauan Pustaka

Berdasarkan tinjauan pustaka, dapat disimpulkan:

1. **Gap Penelitian:** Penelitian terdahulu fokus pada monitoring real-time tanpa database terstruktur, visualisasi historis, dan prediksi.

2. **Database:** MySQL dengan ERD terstruktur dan normalisasi 3NF diperlukan untuk penyimpanan data time series jangka panjang.

3. **Web Application:** Stack Node.js + React.js dipilih karena mudah dipelajari dan single language (JavaScript).

4. **Visualisasi:** Chart.js dipilih karena simple, gratis, dan mendukung berbagai chart types.

5. **Prediksi:** Moving Average dipilih karena sederhana, tidak perlu training, dan cukup akurat untuk proof-of-concept.

6. **Metodologi:** Waterfall dipilih karena sederhana dan cocok untuk skripsi dengan requirements yang sudah jelas.

7. **Testing:** Unit testing + performance testing + user testing cukup untuk memvalidasi sistem.

**Kontribusi Penelitian Ini:**
- Database design untuk time series IoT data
- Web dashboard dengan multiple visualizations
- Prediksi sederhana untuk early warning
- Dataset untuk penelitian lanjutan

**Posisi Penelitian:** Mengisi gap dengan fokus pada **sistem informasi** (database, web app, visualisasi) dan **prediksi sederhana** untuk mendukung decision making peternak.

---

## DAFTAR REFERENSI (IEEE Style)

**Penelitian Terdahulu:**

[1] Hamzah, et al., "Integrasi Sistem Otomatis Kandang Ayam dengan PLTS," *Jurnal Teknik Elektro*, vol. X, no. Y, pp. Z, 2024.

[2] A. Suryanto and M. Ariefin, "Sistem Monitoring Suhu dan Kelembaban Kandang Berbasis IoT," *Jurnal Informatika*, vol. X, no. Y, pp. Z, 2024.

[3] Musyahar, et al., "Otomasi Dispenser Pakan Ayam Bangkok dengan PLTS," *Jurnal Teknik*, vol. X, no. Y, pp. Z, 2025.

**Database:**

[4] A. Silberschatz, H. F. Korth, and S. Sudarshan, *Database System Concepts*, 7th ed. McGraw-Hill, 2019.

[5] R. Elmasri and S. B. Navathe, *Fundamentals of Database Systems*, 7th ed. Pearson, 2015.

**Web Development:**

[6] R. T. Fielding, "Architectural Styles and the Design of Network-based Software Architectures," Ph.D. dissertation, University of California, Irvine, 2000.

[7] Node.js Foundation, "Node.js Documentation," [Online]. Available: https://nodejs.org/docs/. [Accessed: Jan. 14, 2026].

[8] Meta Open Source, "React Documentation," [Online]. Available: https://react.dev/. [Accessed: Jan. 14, 2026].

**Time Series Forecasting:**

[9] G. E. Box, G. M. Jenkins, G. C. Reinsel, and G. M. Ljung, *Time Series Analysis: Forecasting and Control*, 5th ed. John Wiley & Sons, 2015.

[10] R. J. Hyndman and G. Athanasopoulos, *Forecasting: Principles and Practice*, 3rd ed. OTexts, 2021. [Online]. Available: https://otexts.com/fpp3/

**Data Visualization:**

[11] E. R. Tufte, *The Visual Display of Quantitative Information*, 2nd ed. Graphics Press, 2001.

[12] Chart.js Contributors, "Chart.js Documentation," [Online]. Available: https://www.chartjs.org/docs/. [Accessed: Jan. 14, 2026].

**Software Engineering:**

[13] I. Sommerville, *Software Engineering*, 10th ed. Pearson, 2015.

[14] G. J. Myers, C. Sandler, and T. Badgett, *The Art of Software Testing*, 3rd ed. John Wiley & Sons, 2011.

**IoT:**

[15] L. Atzori, A. Iera, and G. Morabito, "The Internet of Things: A Survey," *Computer Networks*, vol. 54, no. 15, pp. 2787-2805, 2010.

**Catatan:** Mahasiswa harus melengkapi referensi penelitian terdahulu [1-3] dengan detail lengkap (volume, nomor, halaman, DOI) sesuai format IEEE.

---

**CATATAN PENTING:**

- BAB II ini sudah **disederhanakan** dibanding versi kompleks
- Hardware hanya 1 tabel ringkasan (bukan 7 halaman)
- Machine Learning hanya bahas Moving Average & Exponential Smoothing (tidak bahas LSTM/deep learning)
- Total ~15 referensi (bukan 30+) yang cukup untuk skripsi S1
- Fokus ke teori yang **benar-benar digunakan** dalam implementasi

# BAB III
# METODOLOGI PENELITIAN

## 3.1 Metode Penelitian

Penelitian ini menggunakan metode **pengembangan sistem** dengan pendekatan **Waterfall sederhana**. Model waterfall dipilih karena:
- Requirements sudah jelas (monitoring + visualisasi + prediksi)
- Tidak banyak perubahan requirements di tengah jalan
- Cocok untuk proyek skripsi dengan timeline terbatas
- Mudah dipahami dan didokumentasikan

### 3.1.1 Tahapan Waterfall

**Gambar 3.1** Model Waterfall

```
┌────────────────────┐
│ 1. Requirements    │ → Analisis kebutuhan sistem
│    Analysis        │   (Des 2025)
└─────────┬──────────┘
          ↓
┌─────────▼──────────┐
│ 2. System Design   │ → Desain database, API, UI
│                    │   (Jan 2026)
└─────────┬──────────┘
          ↓
┌─────────▼──────────┐
│ 3. Implementation  │ → Coding (database, backend, frontend)
│                    │   (Feb-Apr 2026)
└─────────┬──────────┘
          ↓
┌─────────▼──────────┐
│ 4. Testing         │ → Unit test, integration test, user test
│                    │   (Mei 2026)
└─────────┬──────────┘
          ↓
┌─────────▼──────────┐
│ 5. Deployment &    │ → Deploy + dokumentasi
│    Maintenance     │   (Jun 2026)
└────────────────────┘
```

---

## 3.2 Tahapan Penelitian

Penelitian dilaksanakan dalam **5 tahap utama** selama 7 bulan (Des 2025 - Jun 2026).

### 3.2.1 Tahap 1: Requirements Analysis (Desember 2025)

**Durasi:** 3 minggu

**Aktivitas:**

1. **Wawancara dengan Peternak:**
   - Kebutuhan monitoring (parameter apa yang penting?)
   - Kebutuhan visualisasi (grafik apa yang diinginkan?)
   - Kebutuhan prediksi (prediksi untuk berapa jam ke depan?)
   - Frekuensi akses sistem (berapa kali sehari?)

2. **Studi Literatur:**
   - Penelitian terdahulu tentang IoT monitoring
   - Teknik visualisasi data time series
   - Metode prediksi sederhana (moving average, exponential smoothing)

3. **Spesifikasi Kebutuhan:**
   - **Functional Requirements:**
     - Sistem dapat menyimpan data sensor (suhu, kelembaban) setiap 5 menit
     - Sistem dapat menampilkan data real-time dalam bentuk gauge chart
     - Sistem dapat menampilkan grafik historis 7 hari terakhir
     - Sistem dapat memprediksi suhu 6-12 jam ke depan
     - Sistem dapat export data ke Excel

   - **Non-Functional Requirements:**
     - Response time API < 3 detik
     - Database dapat menyimpan data 3 bulan
     - Dashboard mudah digunakan (user-friendly)
     - Sistem dapat diakses via web browser (Chrome, Firefox)

**Output:**
- Dokumen Software Requirements Specification (SRS)
- Transkrip wawancara

---

### 3.2.2 Tahap 2: System Design (Januari 2026)

**Durasi:** 4 minggu

**Aktivitas:**

**A. Database Design (Week 1-2):**
- Perancangan ERD (3 tabel)
- Normalisasi database
- Pembuatan SQL script (DDL)

**B. API Design (Week 2):**
- Spesifikasi 8-10 REST API endpoints
- Request/response format (JSON)

**C. UI Design (Week 3):**
- Wireframe dashboard (low-fidelity)
- Mockup dashboard (Figma - opsional)
- Menentukan layout dan komponen visualisasi

**D. Prediction Algorithm Design (Week 4):**
- Pilih metode: Moving Average atau Exponential Smoothing
- Tentukan window size (berapa data points untuk prediksi?)
- Tentukan evaluation metric (MAE)

**Output:**
- ERD + SQL Script
- API Specification Document
- Wireframe Dashboard
- Algoritma Prediksi (pseudocode)

---

### 3.2.3 Tahap 3: Implementation (Februari - April 2026)

**Durasi:** 12 minggu (3 bulan)

**Breakdown per Bulan:**

**Februari 2026: Database + Backend API (4 minggu)**

Week 1-2: Database & Basic API
- Setup MySQL database
- Execute SQL script (CREATE TABLE)
- Insert sample data
- Setup Node.js + Express project
- Implementasi CRUD API untuk tb_sensor_data

Week 3-4: MQTT Integration & Prediction API
- Integrasi MQTT broker untuk terima data dari ESP32
- Implementasi API untuk historical data (GET /api/sensor/history)
- Implementasi prediction algorithm (moving average)
- Testing API dengan Postman

**Maret 2026: Frontend Dashboard (4 minggu)**

Week 1: Setup React + Layout
- Setup React project
- Implementasi layout (Navbar, Sidebar, Content area)
- Setup routing (Home, Analytics)

Week 2: Real-time Monitoring Page
- Fetch data dari API (/api/sensor/latest)
- Implementasi Gauge Chart (suhu & kelembaban)
- Auto-refresh setiap 30 detik

Week 3: Analytics Page
- Fetch historical data (/api/sensor/history?days=7)
- Implementasi Line Chart (suhu & kelembaban over time)
- Implementasi Bar Chart (konsumsi data per hari)

Week 4: Prediction Page & Export
- Fetch prediction data (/api/predict)
- Tampilkan prediksi suhu 6-12 jam ke depan
- Implementasi export data to Excel (library: xlsx.js)

**April 2026: Integration & Refinement (4 minggu)**

Week 1-2: Hardware Integration
- Setup ESP32 + DHT22
- Programming ESP32 (publish data via MQTT)
- Testing end-to-end: ESP32 → MQTT → Backend → Database

Week 3-4: Bug Fixing & UI Polish
- Testing seluruh fitur
- Fix bugs yang ditemukan
- Improve UI/UX (styling, color, responsiveness)

**Output:**
- Database terinstall dengan data real
- Backend API functional
- Frontend dashboard complete
- Sistem terintegrasi (Hardware → Backend → Frontend)

---

### 3.2.4 Tahap 4: Testing (Mei 2026)

**Durasi:** 4 minggu

**A. Unit Testing (Week 1):**
- Test API endpoints dengan Jest/Mocha
- Min 5 test cases untuk endpoint kritis:
  - GET /api/sensor/latest
  - GET /api/sensor/history
  - GET /api/predict
  - POST /api/sensor (insert data)
  - DELETE /api/sensor/:id

**B. Integration Testing (Week 2):**
- Test end-to-end flow: ESP32 → Backend → Database → Frontend
- Test prediction algorithm dengan data real
- Measure MAE (Mean Absolute Error)

**C. Performance Testing (Week 2):**
- Test response time API dengan tool sederhana (Postman, curl)
- Measure: berapa lama API response untuk query 7 hari data?
- Target: < 3 detik

**D. User Acceptance Testing (Week 3-4):**
- Testing dengan peternak (1-2 orang)
- Task-based testing:
  1. Lihat data real-time
  2. Lihat grafik 7 hari terakhir
  3. Lihat prediksi suhu
  4. Export data to Excel
- Kuesioner sederhana (5-10 pertanyaan):
  - Apakah dashboard mudah digunakan? (Skala 1-5)
  - Apakah grafik mudah dipahami? (Skala 1-5)
  - Apakah prediksi membantu? (Ya/Tidak)
  - Saran perbaikan?

**Output:**
- Laporan Unit Testing (test cases + hasil)
- Laporan Performance Testing (response time)
- Laporan User Testing (kuesioner + feedback)
- Bug list + resolution log

---

### 3.2.5 Tahap 5: Deployment & Documentation (Juni 2026)

**Durasi:** 4 minggu

**Week 1-2: Deployment**
- Deploy backend ke cloud (Heroku / Railway / free tier)
- Deploy frontend ke Vercel / Netlify
- Setup production database (free MySQL hosting atau local server)
- Testing production environment

**Week 3-4: Documentation & Thesis Writing**
- User manual (cara pakai dashboard)
- Technical documentation (cara setup sistem)
- Penulisan BAB IV & BAB V skripsi
- Persiapan sidang

**Output:**
- Sistem deployed dan accessible via internet
- User manual & technical documentation
- Dokumen skripsi lengkap (BAB I-VI)
- Dataset CSV (3 bulan data sensor)

---

## 3.3 Perancangan Sistem

### 3.3.1 Arsitektur Sistem

**Gambar 3.2** Arsitektur Sistem 3-Layer

```
┌───────────────────────────────────────────────┐
│          FRONTEND (React.js)                  │
│  - Dashboard (Real-time monitoring)           │
│  - Analytics (Historical charts)              │
│  - Prediction (Suhu forecast)                 │
└─────────────────┬─────────────────────────────┘
                  │ HTTP/REST API (JSON)
┌─────────────────▼─────────────────────────────┐
│          BACKEND (Node.js + Express)          │
│  - REST API Endpoints (8-10)                  │
│  - MQTT Client (subscribe sensor data)       │
│  - Prediction Algorithm (Moving Average)      │
│  - Database Connection                        │
└─────────────┬───────────┬─────────────────────┘
              │           │ MQTT Publish
              │           │
┌─────────────▼───────┐   │   ┌───────────────┐
│   MySQL Database    │   │   │  ESP32 +      │
│   - tb_kandang      │   └───│  DHT22        │
│   - tb_sensor_data  │       │  (Sensor)     │
│   - tb_user         │       └───────────────┘
└─────────────────────┘
```

**Alur Data:**
1. ESP32 baca sensor → publish via MQTT
2. Backend subscribe MQTT topic → validasi data → simpan ke database
3. Frontend request data via API → Backend query database → return JSON
4. Frontend render charts menggunakan Chart.js

---

### 3.3.2 Perancangan Database

#### A. Entity Relationship Diagram (ERD)

**Gambar 3.3** ERD Sederhana (3 Tabel)

```
┌──────────────────┐
│   tb_kandang     │
├──────────────────┤
│ kandang_id (PK)  │
│ nama_kandang     │
│ lokasi           │
│ created_at       │
└────────┬─────────┘
         │ 1
         │
         │ N
┌────────▼─────────┐
│ tb_sensor_data   │
├──────────────────┤
│ id (PK)          │
│ kandang_id (FK)  │
│ timestamp        │
│ suhu             │
│ kelembaban       │
│ status_pakan     │
└──────────────────┘

┌──────────────────┐
│    tb_user       │  (Opsional - untuk fase lanjut)
├──────────────────┤
│ user_id (PK)     │
│ username         │
│ password_hash    │
└──────────────────┘
```

#### B. SQL Script

**DDL (Data Definition Language):**

```sql
-- Create Database
CREATE DATABASE IF NOT EXISTS db_kandang_ayam;
USE db_kandang_ayam;

-- Table 1: tb_kandang
CREATE TABLE tb_kandang (
    kandang_id INT AUTO_INCREMENT PRIMARY KEY,
    nama_kandang VARCHAR(50) NOT NULL,
    lokasi VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;

-- Table 2: tb_sensor_data
CREATE TABLE tb_sensor_data (
    id INT AUTO_INCREMENT PRIMARY KEY,
    kandang_id INT NOT NULL,
    timestamp DATETIME NOT NULL,
    suhu FLOAT,
    kelembaban FLOAT,
    status_pakan ENUM('tersedia', 'habis') DEFAULT 'tersedia',
    FOREIGN KEY (kandang_id) REFERENCES tb_kandang(kandang_id) ON DELETE CASCADE,
    INDEX idx_timestamp (timestamp),
    INDEX idx_kandang_timestamp (kandang_id, timestamp)
) ENGINE=InnoDB;

-- Table 3: tb_user (opsional)
CREATE TABLE tb_user (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;
```

**Sample Data:**

```sql
-- Insert sample kandang
INSERT INTO tb_kandang (nama_kandang, lokasi) VALUES
('Kandang A1', 'Samarinda, Kalimantan Timur');

-- Insert sample sensor data
INSERT INTO tb_sensor_data (kandang_id, timestamp, suhu, kelembaban, status_pakan)
VALUES
(1, '2026-01-14 10:00:00', 30.5, 65.2, 'tersedia'),
(1, '2026-01-14 10:05:00', 30.3, 65.5, 'tersedia'),
(1, '2026-01-14 10:10:00', 30.7, 64.8, 'tersedia');
```

**Query untuk Analytics:**

```sql
-- Get data 7 hari terakhir (hourly average)
SELECT
    DATE_FORMAT(timestamp, '%Y-%m-%d %H:00:00') AS hour,
    AVG(suhu) AS avg_suhu,
    AVG(kelembaban) AS avg_kelembaban
FROM tb_sensor_data
WHERE kandang_id = 1
  AND timestamp >= DATE_SUB(NOW(), INTERVAL 7 DAY)
GROUP BY hour
ORDER BY hour;

-- Get latest data
SELECT * FROM tb_sensor_data
WHERE kandang_id = 1
ORDER BY timestamp DESC
LIMIT 1;
```

#### C. Normalisasi

Database sudah dalam bentuk **3NF (Third Normal Form)**:
- ✅ **1NF:** Setiap cell atomic (tidak ada repeating groups)
- ✅ **2NF:** Tidak ada partial dependency
- ✅ **3NF:** Tidak ada transitive dependency

---

### 3.3.3 Perancangan API

**Tabel 3.1** REST API Endpoints (8 endpoints)

| Method | Endpoint | Description | Response |
|--------|----------|-------------|----------|
| GET | /api/kandang | Get kandang info | Kandang object |
| GET | /api/sensor/latest | Get latest sensor data | Latest data object |
| GET | /api/sensor/history | Get historical data | Array of data (query: days=7) |
| POST | /api/sensor | Insert new sensor data | Created data object |
| DELETE | /api/sensor/:id | Delete sensor data by ID | {message: "Deleted"} |
| GET | /api/predict | Get temperature prediction | {predictions: [...], mae: 2.1} |
| GET | /api/export | Export data to CSV | CSV file download |
| GET | /api/stats | Get statistics (min, max, avg) | Statistics object |

**Contoh Response:**

```json
// GET /api/sensor/latest
{
  "status": "success",
  "data": {
    "id": 1234,
    "kandang_id": 1,
    "timestamp": "2026-01-14 10:30:00",
    "suhu": 30.5,
    "kelembaban": 65.2,
    "status_pakan": "tersedia"
  }
}

// GET /api/predict
{
  "status": "success",
  "data": {
    "predictions": [
      {"time": "11:00", "suhu": 31.2},
      {"time": "12:00", "suhu": 31.5},
      {"time": "13:00", "suhu": 31.8}
    ],
    "method": "moving_average",
    "mae": 2.1
  }
}
```

---

### 3.3.4 Algoritma Prediksi Suhu (Moving Average)

**Metode:** Simple Moving Average (SMA)

**Konsep:**
Prediksi suhu pada waktu t+1 adalah rata-rata dari n data points sebelumnya.

**Formula:**

```
Prediksi(t+1) = (Suhu(t) + Suhu(t-1) + ... + Suhu(t-n+1)) / n
```

**Pseudocode:**

```javascript
function predictTemperature(historicalData, windowSize, horizon) {
  // historicalData: array of temperature values (last N hours)
  // windowSize: berapa data points untuk averaging (e.g., 12 = 12 hours)
  // horizon: berapa jam ke depan (e.g., 6 hours)

  const predictions = [];

  for (let i = 0; i < horizon; i++) {
    // Take last 'windowSize' values
    const window = historicalData.slice(-windowSize);

    // Calculate average
    const sum = window.reduce((a, b) => a + b, 0);
    const average = sum / window.length;

    // Add prediction to result
    predictions.push(average);

    // Append prediction to historical data for next iteration
    historicalData.push(average);
  }

  return predictions;
}

// Example usage:
const lastNHours = [30.5, 30.3, 30.7, 30.9, 31.2, 31.0, 30.8, 30.6, 30.5, 30.4, 30.6, 30.8]; // 12 hours
const windowSize = 6; // Average dari 6 data terakhir
const horizon = 6; // Prediksi 6 jam ke depan

const predictions = predictTemperature(lastNHours, windowSize, horizon);
// Output: [30.65, 30.68, 30.70, ...]
```

**Evaluasi Prediksi:**

Menggunakan **MAE (Mean Absolute Error)**:

```
MAE = (1/n) × Σ|Actual - Predicted|
```

**Target:** MAE < 2.5°C (error rata-rata < 2.5 derajat)

**Testing Prediksi:**
1. Ambil data historis 1 bulan
2. Gunakan 70% data untuk "training" (menentukan best window size)
3. Gunakan 30% data untuk testing
4. Hitung MAE
5. Jika MAE > 2.5°C, coba window size lain (trial-and-error)

---

### 3.3.5 Perancangan Dashboard UI

**Wireframe Dashboard:**

```
┌─────────────────────────────────────────────────────────┐
│  Navbar: [Logo] Sistem Monitoring Kandang Ayam         │
├─────────┬───────────────────────────────────────────────┤
│ Sidebar │  Dashboard - Real-time Monitoring             │
│         │  Last Update: 14 Jan 2026 10:30               │
│ - Home  │  ┌──────────┐ ┌──────────┐ ┌──────────┐      │
│ - Data  │  │  Gauge   │ │  Gauge   │ │  Status  │      │
│ - Predik│  │  Suhu    │ │ Humid    │ │  Pakan   │      │
│         │  │  30.5°C  │ │  65% RH  │ │ Tersedia │      │
│         │  └──────────┘ └──────────┘ └──────────┘      │
│         │                                                │
│         │  Grafik Historis (7 Hari Terakhir)           │
│         │  ┌──────────────────────────────────────┐    │
│         │  │                                      │    │
│         │  │  [Line Chart: Suhu & Kelembaban]    │    │
│         │  │                                      │    │
│         │  └──────────────────────────────────────┘    │
└─────────┴───────────────────────────────────────────────┘
```

**4 Jenis Visualisasi:**

1. **Gauge Chart** (Real-time)
   - Tampilkan suhu saat ini (dengan range 25-35°C)
   - Tampilkan kelembaban saat ini (dengan range 0-100%)
   - Color coding: Hijau (normal), Kuning (warning), Merah (danger)

2. **Line Chart** (Historical)
   - X-axis: Waktu (7 hari terakhir, hourly)
   - Y-axis: Suhu & Kelembaban
   - 2 lines: Suhu (red), Kelembaban (blue)

3. **Bar Chart** (Daily Average)
   - X-axis: Tanggal (7 hari terakhir)
   - Y-axis: Rata-rata suhu per hari
   - Untuk analisis trend harian

4. **Data Table** (Raw Data)
   - Kolom: Timestamp, Suhu, Kelembaban, Status Pakan
   - Pagination: 20 rows per page
   - Search & filter

---

### 3.3.6 Rencana Pengujian

**A. Unit Testing (5 Test Cases)**

```javascript
// Test 1: GET /api/sensor/latest should return latest data
test('GET /api/sensor/latest returns latest data', async () => {
  const response = await request(app).get('/api/sensor/latest');
  expect(response.status).toBe(200);
  expect(response.body.data).toHaveProperty('suhu');
  expect(response.body.data).toHaveProperty('kelembaban');
});

// Test 2: POST /api/sensor should insert data
test('POST /api/sensor inserts new data', async () => {
  const newData = {
    kandang_id: 1,
    suhu: 30.5,
    kelembaban: 65.2
  };
  const response = await request(app).post('/api/sensor').send(newData);
  expect(response.status).toBe(201);
  expect(response.body.data.id).toBeDefined();
});

// Test 3-5: Similar tests for other endpoints
```

**B. Performance Testing**

- Test response time untuk GET /api/sensor/history?days=7
- Measure dengan Postman atau curl
- Target: < 3 detik

**C. User Testing**

Kuesioner Sederhana (5 pertanyaan):

1. Apakah dashboard mudah digunakan? (Skala 1-5)
2. Apakah grafik mudah dipahami? (Skala 1-5)
3. Apakah prediksi suhu membantu untuk perencanaan? (Ya/Tidak)
4. Fitur apa yang paling berguna? (Open text)
5. Saran perbaikan? (Open text)

---

## 3.4 Jadwal Penelitian

**Tabel 3.2** Jadwal Penelitian (7 Bulan)

| Tahap | Kegiatan | Des 25 | Jan 26 | Feb 26 | Mar 26 | Apr 26 | Mei 26 | Jun 26 |
|-------|----------|--------|--------|--------|--------|--------|--------|--------|
| 1 | Requirements Analysis | ✓✓ | | | | | | |
| 2 | System Design | | ✓✓ | | | | | |
| 3 | Implementation (DB + Backend) | | | ✓✓ | | | | |
| 3 | Implementation (Frontend) | | | | ✓✓ | | | |
| 3 | Integration & Refinement | | | | | ✓✓ | | |
| 4 | Testing (Unit, Performance, User) | | | | | | ✓✓ | |
| 5 | Deployment & Documentation | | | | | | ✓ | ✓✓ |

---

## 3.5 Penutup BAB III

Metodologi penelitian ini dirancang agar:
- ✅ **Sederhana dan realistis** untuk mahasiswa S1
- ✅ **Terstruktur** dengan tahapan yang jelas (waterfall)
- ✅ **Fokus Informatika** (database, API, visualisasi, prediksi)
- ✅ **Feasible** dalam 7 bulan

**Deliverables Akhir:**
1. Database MySQL dengan 3 tabel + ERD
2. Backend API dengan 8 endpoints (Node.js)
3. Frontend Dashboard dengan 4 visualisasi (React.js + Chart.js)
4. Algoritma prediksi suhu (Moving Average)
5. Laporan testing (unit test, performance test, user test)
6. Dataset CSV (3 bulan data sensor)
7. Dokumentasi (user manual + technical doc)

**Kontribusi Informatika:**
- Database design untuk time series data
- Web dashboard untuk visualisasi IoT data
- Prediksi time series dengan metode statistik sederhana
- Dataset untuk penelitian lanjutan

---

**PERBEDAAN DENGAN VERSI KOMPLEKS:**

| Aspek | Versi Kompleks | Versi Ringan (Ini) |
|-------|----------------|-------------------|
| Database | 5 tabel | 3 tabel |
| API | 15+ endpoints | 8 endpoints |
| ML Model | LSTM (deep learning) | Moving Average (statistik) |
| Visualisasi | 7 jenis | 4 jenis |
| Testing | Unit + Integration + E2E + UAT | Unit + Performance + User test sederhana |
| Metodologi | Agile-Scrum (4 sprint) | Waterfall sederhana |
| Durasi | 8 bulan | 7 bulan |
| Kompleksitas | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |

**Versi ini JAUH LEBIH REALISTIS untuk dikerjakan mahasiswa S1!**

