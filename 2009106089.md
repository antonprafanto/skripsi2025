# üéì PANDUAN SUPER LENGKAP & SIMPEL - REVISI PROPOSAL SKRIPSI

**Untuk:** Rizky Hamdani (2009106089)
**Dari:** Dosen Pembimbing
**Tujuan:** Revisi proposal agar lebih Informatika, dengan panduan **STEP-BY-STEP SANGAT DETAIL**

---

## üö® PENTING! BACA INI DULU

Pak/Bu dosen paham kalian mahasiswa semester akhir yang:
- ‚úÖ Sudah capek kuliah bertahun-tahun
- ‚úÖ Pengen cepat wisuda
- ‚úÖ Mungkin sambil cari kerja
- ‚úÖ Gak mau ribet-ribet
- ‚úÖ **Belum tentu expert programming**

**JADI, INI VERSI SUPER SIMPEL & SUPER DETAIL!**

Target: **8 minggu selesai** (2 bulan)
Coding: **80% sudah jadi template** (tinggal copy-paste)
Riset: **1 eksperimen aja** (bukan 3 seperti versi lengkap)
Panduan: **Step-by-step dari NOL!**

---

## üìã APA YANG BERUBAH DARI PROPOSAL LAMA?

### ‚ùå Yang Dihapus (Terlalu Ribet):
- ~~3 benchmark berbeda~~ ‚Üí **Cukup 1 benchmark**
- ~~15-20 paper untuk literature review~~ ‚Üí **Cukup 5-7 paper**
- ~~Statistik kompleks (ANOVA, t-test, dll)~~ ‚Üí **Cukup perbandingan grafik**
- ~~480 eksperimen~~ ‚Üí **Cukup 12 eksperimen**
- ~~16 minggu timeline~~ ‚Üí **8 minggu**

### ‚úÖ Yang Tetap Ada (Supaya Tetap Informatika):
- ‚úÖ Fokus ke algoritma paralel (bukan cuma CRUD)
- ‚úÖ Ada perbandingan performa
- ‚úÖ Ada eksperimen nyata
- ‚úÖ Tetap ada kontribusi ilmiah

---

## üéØ JUDUL BARU (Pilih Salah Satu)

### REKOMENDASI #1 (PALING GAMPANG):
**"Implementasi Paralelisasi Thread untuk Optimasi Batch Processing Invoice dengan Studi Kasus pada PT XYZ"**

**Kenapa gampang?**
- Cuma pakai **Thread** (gak perlu Process/Async)
- Fokus ke **satu perusahaan** (PT XYZ = tempat magang/kerjaan kamu)
- Cukup bandingkan: **Sequential vs Thread** (2 metode aja!)

### REKOMENDASI #2 (Kalau gak ada case study):
**"Perbandingan Kinerja Sequential dan Parallel Threading pada Sistem Generasi Invoice Batch"**

**Kenapa juga gampang?**
- Masih cuma 2 metode: Sequential vs Thread
- "Perbandingan Kinerja" = tinggal ukur waktu dan bikin grafik
- Gak perlu machine learning atau sistem terdistribusi

---

## üìñ BAB I - PENDAHULUAN (VERSI LENGKAP!)

### 1.1 Latar Belakang (3-4 Paragraf)

**PARAGRAF 1:** Masalah di dunia nyata (Real-world problem)
```
Proses pembuatan invoice dalam jumlah besar (batch processing) merupakan
kebutuhan umum di berbagai perusahaan, terutama perusahaan yang memiliki
banyak klien. Sebagai contoh, sebuah perusahaan distributor yang harus
membuat 1000 invoice per hari dengan sistem sequential (satu per satu)
dapat membutuhkan waktu hingga 2-3 jam. Hal ini menghambat efisiensi
operasional dan dapat menyebabkan keterlambatan pengiriman invoice ke klien,
yang pada akhirnya dapat mempengaruhi cash flow perusahaan.
```

**PARAGRAF 2:** Solusi teknis (Parallel Processing)
```
Salah satu pendekatan untuk mengatasi masalah tersebut adalah dengan menerapkan
teknik parallel processing menggunakan thread. Parallel processing adalah teknik
pemrosesan dimana beberapa task dijalankan secara bersamaan (concurrent) dalam
satu program, sehingga dapat mempercepat waktu pemrosesan secara signifikan.
Thread merupakan unit terkecil dari eksekusi dalam sebuah proses yang memungkinkan
program untuk melakukan beberapa pekerjaan secara simultan. Dalam konteks web
programming, konsep ini mirip dengan server yang dapat handle multiple HTTP
requests secara bersamaan, dimana setiap request diproses oleh thread yang berbeda.
```

**PARAGRAF 3:** State-of-the-art & gap (Penelitian sebelumnya & kekurangannya)
```
Beberapa penelitian sebelumnya telah meneliti penggunaan parallel processing
untuk berbagai aplikasi, namun belum banyak yang fokus pada implementasi spesifik
untuk batch processing invoice menggunakan Python dengan threading. Penelitian
oleh [peneliti A, tahun] menggunakan Java untuk batch processing, sementara
[peneliti B, tahun] fokus pada multiprocessing yang memiliki overhead lebih besar.
Oleh karena itu, diperlukan penelitian untuk mengukur seberapa efektif threading
dalam Python untuk kasus batch processing invoice, mengingat Python memiliki
Global Interpreter Lock (GIL) yang dapat mempengaruhi performa thread.
```

**PARAGRAF 4:** Tujuan penelitian (Contribution)
```
Penelitian ini bertujuan untuk mengimplementasikan dan membandingkan kinerja
antara pemrosesan sequential dan parallel threading pada sistem generasi invoice.
Parameter yang diukur adalah waktu eksekusi dan throughput (jumlah invoice per detik).
Hasil penelitian diharapkan dapat memberikan rekomendasi praktis untuk implementasi
sistem batch processing yang lebih efisien, serta memberikan baseline performance
untuk pengembangan sistem invoice di industri.
```

### 1.2 Rumusan Masalah (2-3 Pertanyaan)

1. Bagaimana cara mengimplementasikan parallel threading untuk batch processing invoice menggunakan Python?
2. Berapa peningkatan kinerja (speedup) yang didapat dari metode parallel threading dibandingkan pemrosesan sequential?
3. (Opsional) Pada jumlah worker berapa parallel threading memberikan performa optimal?

### 1.3 Batasan Masalah (Supaya Gak Kebablasan!)

Penelitian ini dibatasi pada:
1. Perbandingan **2 metode** pemrosesan: Sequential dan Parallel Threading
2. Bahasa pemrograman: **Python 3.8+**
3. Database: **PostgreSQL** atau **SQLite**
4. Format invoice: **PDF sederhana** menggunakan library ReportLab
5. Ukuran dataset: **100, 500, 1000 invoice** (3 ukuran data)
6. Jumlah worker thread: **2, 4, 8 worker** (3 variasi)
7. Metrik evaluasi: **Waktu eksekusi** dan **throughput**
8. Platform: **Single machine** (tidak distributed system)

### 1.4 Tujuan Penelitian

1. Mengimplementasikan sistem batch processing invoice dengan metode **sequential processing**
2. Mengimplementasikan sistem batch processing invoice dengan metode **parallel threading**
3. Membandingkan kinerja kedua metode berdasarkan **waktu eksekusi** dan **throughput**
4. Menentukan jumlah worker thread optimal untuk batch processing invoice

### 1.5 Manfaat Penelitian

#### Manfaat Akademik:
- Memberikan baseline performance untuk penelitian batch processing dengan Python threading
- Menambah literatur tentang perbandingan sequential vs parallel processing di domain invoice generation
- Memberikan insight tentang efek GIL pada I/O-bound tasks

#### Manfaat Praktis:
- **Untuk Mahasiswa:** Memahami konsep parallel processing dalam praktik nyata dan meningkatkan skill programming
- **Untuk Perusahaan:** Mendapat sistem invoice yang lebih cepat dan hemat waktu operasional
- **Untuk Industri:** Rekomendasi implementasi batch processing yang efisien

### 1.6 Sistematika Penulisan (Opsional, tapi bagus kalau ada)

- **BAB I PENDAHULUAN:** Latar belakang, rumusan masalah, batasan, tujuan, manfaat
- **BAB II TINJAUAN PUSTAKA:** Penelitian terkait dan landasan teori
- **BAB III METODE PENELITIAN:** Jenis penelitian, tahapan, eksperimen, analisis
- **BAB IV HASIL DAN PEMBAHASAN:** Hasil eksperimen dan analisis
- **BAB V PENUTUP:** Kesimpulan dan saran

---

## üìö BAB II - TINJAUAN PUSTAKA (VERSI SUPER LENGKAP!)

### 2.1 Penelitian Terkait (5-7 Paper)

#### Cara Mencari Paper (STEP-BY-STEP!):

**LANGKAH 1: Buka Google Scholar**
```
1. Buka browser (Chrome/Firefox)
2. Ke https://scholar.google.com
3. Set bahasa ke English (supaya hasil lebih banyak)
```

**LANGKAH 2: Gunakan Keyword yang Tepat**

Coba keyword ini satu per satu:
```
1. "parallel processing batch generation"
2. "thread-based invoice processing"
3. "performance comparison sequential parallel python"
4. "concurrent programming performance optimization"
5. "Python threading GIL performance"
6. "batch processing optimization"
```

**LANGKAH 3: Filter Hasil**
```
1. Klik "Since [tahun]" di sidebar kiri, pilih 2019-2024 (5 tahun terakhir)
2. Cari yang ada [PDF] atau link download
3. Prioritaskan yang citationnya banyak (>10 citation)
```

**LANGKAH 4: Download & Baca Smart**
```
JANGAN baca semua paper dari awal sampai akhir!

Baca yang penting aja:
1. ABSTRACT (1 paragraf) ‚Üí Cari tahu topik utama
2. INTRODUCTION paragraf terakhir ‚Üí Cari tahu contribution
3. METHODOLOGY ‚Üí Cari tahu metode yang dipakai
4. CONCLUSION ‚Üí Cari tahu hasil akhir

Cukup 10-15 menit per paper!
```

#### Template Tabel Penelitian Terkait:

| No | Penulis & Tahun | Judul | Metode | Hasil | Gap/Perbedaan |
|----|-----------------|-------|--------|-------|---------------|
| 1 | Smith et al., 2022 | Parallel Processing for Document Generation | Multiprocessing dengan Java | Speedup 4.2x dengan 8 cores | Menggunakan Java dan multiprocessing, bukan Python threading |
| 2 | Li & Wang, 2021 | Thread-Based Optimization in Web Applications | Threading dengan Python Flask | Throughput naik 3.5x | Fokus ke web request handling, bukan batch processing |
| 3 | Kumar, 2023 | Batch Processing Optimization Techniques | Sequential vs Async I/O | Async 2.8x lebih cepat | Menggunakan asyncio, bukan threading |
| 4 | Zhang et al., 2020 | Performance Analysis of Python Concurrency | Thread vs Process vs Async | Thread baik untuk I/O-bound | Tidak spesifik untuk invoice generation |
| 5 | Anderson, 2022 | Invoice Automation Using ML | Machine Learning | Akurasi 95% | Fokus ke ML untuk data extraction, bukan optimization |

**TIPS:**
- Kalau susah nemuin paper yang 100% sama, gak masalah!
- Yang penting ada kesamaan di **topik** (parallel processing / batch processing / optimization)
- **Gap/Perbedaan** adalah kunci: ini yang bikin penelitian kamu penting!

#### Contoh Narasi Penelitian Terkait (Cara Nulis di Laporan):

```
Smith et al. (2022) melakukan penelitian tentang parallel processing untuk
document generation menggunakan multiprocessing dengan bahasa Java. Hasil
penelitian menunjukkan speedup sebesar 4.2x dengan 8 cores. Namun, penelitian
tersebut menggunakan Java dan multiprocessing yang memiliki overhead memory
lebih besar dibandingkan threading, serta tidak fokus pada invoice generation
khususnya.

Li & Wang (2021) meneliti thread-based optimization pada web application
menggunakan Python Flask. Penelitian mereka fokus pada handling concurrent
HTTP requests dan berhasil meningkatkan throughput sebesar 3.5x. Meskipun
menggunakan Python threading, konteks penelitian berbeda dengan batch
processing invoice yang menjadi fokus penelitian ini.

[Lanjutkan untuk 3-5 paper lainnya...]

Berdasarkan penelitian-penelitian di atas, belum ada yang spesifik meneliti
perbandingan sequential vs parallel threading untuk batch processing invoice
menggunakan Python dengan mempertimbangkan efek GIL. Oleh karena itu, penelitian
ini akan mengisi gap tersebut dengan...
```

### 2.2 Landasan Teori (LENGKAP dengan Penjelasan!)

#### A. Batch Processing

**Definisi:**
```
Batch processing adalah metode pemrosesan data dalam jumlah besar secara
berkelompok (batch) pada satu waktu, tanpa interaksi pengguna secara real-time.
Data dikumpulkan terlebih dahulu, kemudian diproses sekaligus dalam satu batch.
```

**Contoh Sederhana:**
```
Analogi: Kamu punya 100 baju kotor.

Sequential: Cuci 1 baju ‚Üí tunggu selesai ‚Üí cuci baju ke-2 ‚Üí dst
Batch Processing: Kumpulkan 100 baju ‚Üí cuci sekaligus dalam 1x proses

Batch processing lebih efisien untuk volume besar!
```

**Karakteristik:**
- Volume data besar
- Tidak memerlukan interaksi real-time
- Biasanya dijadwalkan (scheduled) pada waktu tertentu
- Efisien untuk resource utilization

**Contoh di Dunia Nyata:**
- Generate 1000 invoice sekaligus (kasus kita!)
- Payroll processing (gaji karyawan sebulan sekali)
- Bank statement generation
- Email newsletter untuk 10,000 subscriber

**Referensi:**
```
[1] Tanenbaum, A. S. (2015). Modern Operating Systems. Pearson.
[2] Silberschatz, A., et al. (2018). Operating System Concepts. Wiley.
```

#### B. Sequential Processing

**Definisi:**
```
Sequential processing adalah metode pemrosesan data secara berurutan, satu per satu,
dimana task berikutnya hanya dimulai setelah task sebelumnya selesai.
```

**Pseudocode:**
```
function sequential_process(tasks):
    results = []
    for each task in tasks:
        result = execute(task)    # Tunggu sampai selesai
        results.append(result)
    return results

Total waktu = waktu_task1 + waktu_task2 + ... + waktu_taskN
```

**Kelebihan:**
- ‚úÖ Simple dan mudah dipahami
- ‚úÖ Predictable (hasil selalu sama sequence-nya)
- ‚úÖ No race condition
- ‚úÖ Debugging mudah

**Kekurangan:**
- ‚ùå Lambat untuk volume besar
- ‚ùå Resource tidak dimanfaatkan maksimal (CPU idle saat waiting I/O)
- ‚ùå Tidak scalable

#### C. Parallel Processing dengan Thread

**Definisi:**
```
Parallel processing adalah teknik pemrosesan dimana beberapa task dijalankan
secara bersamaan (concurrent atau parallel) untuk mempercepat waktu total.

Thread adalah unit eksekusi terkecil dalam sebuah process yang dapat berjalan
secara concurrent dengan thread lain dalam process yang sama.
```

**Pseudocode:**
```
function parallel_process(tasks, num_workers):
    pool = create_thread_pool(num_workers)
    results = []

    for each task in tasks:
        pool.submit(task)    # Submit ke thread pool (tidak tunggu!)

    wait_all_complete()
    return results

Total waktu ‚âà waktu_task_terlama + overhead
```

**Konsep Penting:**

1. **Thread vs Process:**
```
THREAD:
- Lightweight (ringan)
- Share memory dengan thread lain di process yang sama
- Overhead kecil
- Cocok untuk I/O-bound tasks (baca file, network, database)

PROCESS:
- Heavy (berat)
- Punya memory sendiri (isolated)
- Overhead besar
- Cocok untuk CPU-bound tasks (komputasi berat)
```

2. **Global Interpreter Lock (GIL) di Python:**
```
GIL adalah mutex yang memproteksi akses ke Python objects, preventing multiple
threads dari executing Python bytecodes sekaligus.

Artinya: Di Python, thread TIDAK benar-benar parallel untuk CPU-bound tasks!

TAPI: GIL dirilis saat I/O operation (read file, network, sleep)
JADI: Thread SANGAT EFEKTIF untuk I/O-bound tasks (seperti generate PDF invoice!)
```

**Ilustrasi GIL:**
```
CPU-bound task (komputasi berat):
Thread 1: [==GIL==]        [==GIL==]        [==GIL==]
Thread 2:          [==GIL==]        [==GIL==]
‚Üë Thread bergantian pakai GIL ‚Üí TIDAK ADA SPEEDUP!

I/O-bound task (baca file, generate PDF, database):
Thread 1: [==GIL==] [I/O...release GIL...] [==GIL==]
Thread 2:          [==GIL==] [I/O...release GIL...] [==GIL==]
                              ‚Üë
                         GIL dirilis saat I/O
                    Thread lain bisa jalan!
‚Üë SPEEDUP SIGNIFIKAN! (Karena invoice generation = I/O-bound)
```

**Kelebihan Thread:**
- ‚úÖ Lebih cepat untuk I/O-bound tasks
- ‚úÖ Overhead kecil (lightweight)
- ‚úÖ Share memory (mudah komunikasi antar thread)

**Kekurangan Thread:**
- ‚ùå GIL limiting untuk CPU-bound tasks (Python)
- ‚ùå Potensi race condition (butuh locking)
- ‚ùå Debugging lebih susah

**Referensi:**
```
[3] Beazley, D. (2010). Understanding the Python GIL. PyCon.
[4] Gorelick, M., & Ozsvald, I. (2020). High Performance Python. O'Reilly.
```

#### D. ThreadPoolExecutor (Library Python)

**Definisi:**
```
ThreadPoolExecutor adalah class dari concurrent.futures module yang menyediakan
high-level interface untuk menjalankan tasks secara asynchronous menggunakan
pool of threads.
```

**Cara Kerja:**
```
1. Buat thread pool dengan N worker threads
2. Submit tasks ke pool (via executor.submit())
3. Tasks masuk ke queue
4. Worker threads ambil task dari queue dan execute
5. Hasil disimpan di Future object
6. Main thread bisa tunggu semua selesai atau ambil hasil satu-satu
```

**Contoh Kode:**
```python
from concurrent.futures import ThreadPoolExecutor

def process_invoice(invoice_id):
    # Generate PDF untuk 1 invoice
    pdf = generate_pdf(invoice_id)
    save_to_database(pdf)
    return pdf

# Buat pool dengan 4 worker threads
with ThreadPoolExecutor(max_workers=4) as executor:
    invoice_ids = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    # Submit 10 tasks ke pool
    futures = [executor.submit(process_invoice, id) for id in invoice_ids]

    # Tunggu semua selesai
    results = [future.result() for future in futures]
```

**Parameter Penting:**
- `max_workers`: Jumlah thread dalam pool (biasanya 2-8 untuk I/O-bound)
- `executor.submit(func, *args)`: Submit task ke pool
- `future.result()`: Ambil hasil (blocking sampai selesai)

#### E. Metrik Kinerja (Performance Metrics)

**1. Waktu Eksekusi (Execution Time)**

```
Definisi: Total waktu yang dibutuhkan dari mulai sampai selesai eksekusi

Formula:
T = T_end - T_start

Unit: detik (seconds)

Contoh:
T_start = 10:00:00
T_end = 10:02:30
T = 150 detik (2 menit 30 detik)
```

**2. Throughput**

```
Definisi: Jumlah task yang berhasil diproses per unit waktu

Formula:
Throughput = N / T

dimana:
N = jumlah task yang diproses
T = waktu eksekusi total

Unit: tasks per second (atau invoice per second untuk kasus kita)

Contoh:
N = 1000 invoice
T = 150 detik
Throughput = 1000 / 150 = 6.67 invoice/detik
```

**3. Speedup**

```
Definisi: Rasio antara waktu sequential dengan waktu parallel,
          menunjukkan seberapa banyak kita "lebih cepat"

Formula:
S = T_sequential / T_parallel

Interpretasi:
S = 1   ‚Üí tidak ada speedup
S = 2   ‚Üí 2x lebih cepat (parallel 2x lebih cepat dari sequential)
S = 4   ‚Üí 4x lebih cepat

Contoh:
T_sequential = 150 detik
T_parallel = 45 detik
S = 150 / 45 = 3.33

Artinya: Parallel threading 3.33x lebih cepat dari sequential
```

**4. Efficiency (Opsional)**

```
Definisi: Seberapa efektif penggunaan worker threads

Formula:
E = S / N

dimana:
S = speedup
N = jumlah worker threads

Range: 0 sampai 1 (atau 0% sampai 100%)

Contoh:
S = 3.33
N = 4 workers
E = 3.33 / 4 = 0.83 = 83%

Artinya: Worker threads dimanfaatkan 83% (bagus!)

Interpretasi:
E = 100%  ‚Üí Perfect (ideal speedup)
E = 75-90% ‚Üí Sangat baik
E = 50-75% ‚Üí Baik
E < 50%   ‚Üí Kurang efisien (overhead terlalu besar)
```

**Referensi:**
```
[5] Hennessy, J. L., & Patterson, D. A. (2017). Computer Architecture:
    A Quantitative Approach. Morgan Kaufmann.
```

#### F. Teknologi yang Digunakan

**1. Python 3.8+**
- Bahasa pemrograman high-level, interpreted
- Populer untuk data processing, automation, web development
- Punya library lengkap untuk concurrent programming

**2. concurrent.futures**
- Built-in library Python untuk concurrent execution
- Menyediakan ThreadPoolExecutor dan ProcessPoolExecutor
- High-level interface, mudah digunakan

**3. ReportLab**
- Library Python untuk generate PDF
- Mendukung layout kompleks, gambar, tabel
- Widely used untuk invoice, report generation

**4. PostgreSQL / SQLite**
- Database untuk menyimpan data invoice
- PostgreSQL: Production-grade, scalable
- SQLite: Lightweight, embedded database

**5. Matplotlib & Pandas**
- Matplotlib: Library untuk visualisasi data (grafik)
- Pandas: Library untuk data analysis dan manipulation

---

## üî¨ BAB III - METODE PENELITIAN (SUPER DETAIL!)

### 3.1 Jenis Penelitian

Penelitian ini menggunakan **metode eksperimental (experimental research)**.

**Definisi:**
```
Penelitian eksperimental adalah penelitian yang melakukan percobaan dengan
memanipulasi variabel independent (input) dan mengukur efeknya terhadap
variabel dependent (output), sambil mengontrol variabel lain.
```

**Dalam konteks penelitian ini:**
- **Variabel Independent:** Metode pemrosesan (Sequential vs Thread) dan jumlah worker
- **Variabel Dependent:** Waktu eksekusi dan throughput
- **Variabel Kontrol:** Hardware, dataset, algoritma generate PDF

### 3.2 Tahapan Penelitian (8 Minggu Detail!)

#### MINGGU 1-2: Setup & Implementasi Sequential

**Hari 1-2: Setup Environment**
```
‚ñ° Install Python 3.8+ dari https://www.python.org/downloads/
  - Download installer
  - Jalankan installer, centang "Add Python to PATH"
  - Test: buka CMD, ketik "python --version"

‚ñ° Install VS Code dari https://code.visualstudio.com/
  - Download installer
  - Install Python extension

‚ñ° Buat folder project:
  mkdir c:\skripsi_invoice
  cd c:\skripsi_invoice

‚ñ° Buat virtual environment:
  python -m venv venv
  venv\Scripts\activate     (Windows)
  source venv/bin/activate  (Mac/Linux)

‚ñ° Install libraries:
  pip install reportlab psycopg2-binary matplotlib pandas
```

**Hari 3-5: Implementasi Sequential**
```
‚ñ° Buat file invoice_generator.py (copy dari template)
‚ñ° Test generate 1 invoice
‚ñ° Buat file sequential_processor.py
‚ñ° Test process 10 invoice
‚ñ° Test process 100 invoice
‚ñ° Catat hasilnya
```

**Hari 6-7: Setup Database (Opsional)**
```
OPSI A: Pakai SQLite (GAMPANG, RECOMMENDED!)
‚ñ° Sudah built-in di Python, gak perlu install
‚ñ° Buat file database.py untuk connection
‚ñ° Test insert & read data

OPSI B: Pakai PostgreSQL (Kalau mau lebih real)
‚ñ° Install PostgreSQL dari https://www.postgresql.org/
‚ñ° Buat database "invoice_db"
‚ñ° Buat tabel "invoices"
‚ñ° Test connection dari Python

OPSI C: Skip Database (PALING GAMPANG!)
‚ñ° Pakai dummy data aja (list of dict)
‚ñ° Gak usah pake database sama sekali
‚ñ° (Tetap valid untuk eksperimen!)
```

#### MINGGU 3-4: Implementasi Parallel Threading

**Hari 8-10: Implementasi Thread Processor**
```
‚ñ° Buat file thread_processor.py (copy dari template)
‚ñ° Pahami cara kerja ThreadPoolExecutor
‚ñ° Test dengan 2 workers
‚ñ° Test dengan 4 workers
‚ñ° Test dengan 8 workers
‚ñ° Bandingkan hasil dengan sequential
```

**Hari 11-12: Debugging & Optimization**
```
‚ñ° Cek apakah semua invoice ter-generate dengan benar
‚ñ° Cek apakah ada race condition (seharusnya tidak ada)
‚ñ° Tambah logging untuk monitoring
‚ñ° Fix bugs (kalau ada)
```

**Hari 13-14: Buat Benchmark Script**
```
‚ñ° Buat file run_benchmark.py (copy dari template)
‚ñ° Test jalankan via command line
‚ñ° Verifikasi hasil tersimpan ke CSV
‚ñ° Dry run semua eksperimen
```

#### MINGGU 5-6: Eksperimen & Data Collection

**Hari 15-16: Persiapan Dataset**
```
‚ñ° Generate dummy data 100 invoice (JSON/CSV)
‚ñ° Generate dummy data 500 invoice
‚ñ° Generate dummy data 1000 invoice
‚ñ° Backup semua dataset
```

**Hari 17: EKSPERIMEN FULL (1-2 jam)**
```
Matikan aplikasi lain (supaya gak ganggu)!
Pastikan laptop dalam kondisi optimal (charger, gak overheat)!

Jalankan command berikut (12 eksperimen):

# Sequential (3 run)
python run_benchmark.py --method sequential --invoices 100
python run_benchmark.py --method sequential --invoices 500
python run_benchmark.py --method sequential --invoices 1000

# Thread dengan 2 workers (3 run)
python run_benchmark.py --method thread --workers 2 --invoices 100
python run_benchmark.py --method thread --workers 2 --invoices 500
python run_benchmark.py --method thread --workers 2 --invoices 1000

# Thread dengan 4 workers (3 run)
python run_benchmark.py --method thread --workers 4 --invoices 100
python run_benchmark.py --method thread --workers 4 --invoices 500
python run_benchmark.py --method thread --workers 4 --invoices 1000

# Thread dengan 8 workers (3 run)
python run_benchmark.py --method thread --workers 8 --invoices 100
python run_benchmark.py --method thread --workers 8 --invoices 500
python run_benchmark.py --method thread --workers 8 --invoices 1000

SELESAI! Cek file results.csv
BACKUP results.csv ke 3 tempat: Google Drive, USB, Email!
```

**Hari 18-20: Data Cleaning & Validation**
```
‚ñ° Buka results.csv di Excel/Google Sheets
‚ñ° Cek apakah ada data yang aneh (outlier)
‚ñ° Kalau ada yang aneh, ulangi eksperimen untuk data tersebut
‚ñ° Buat tabel hasil yang rapi
```

#### MINGGU 7: Analisis Data & Visualisasi

**Hari 21-22: Generate Grafik**
```
‚ñ° Jalankan: python visualize_results.py
‚ñ° Cek file comparison_results.png
‚ñ° Kalau kurang bagus, edit parameter (size, color, label)
‚ñ° Buat grafik tambahan (bar chart, speedup chart)
```

**Hari 23-24: Hitung Metrik**
```
‚ñ° Hitung speedup untuk setiap kombinasi
‚ñ° Hitung efficiency untuk thread
‚ñ° Buat tabel rangkuman metrik
‚ñ° Tulis interpretasi awal
```

**Hari 25-27: Tulis BAB IV (Hasil & Pembahasan)**
```
‚ñ° Masukkan tabel hasil eksperimen
‚ñ° Masukkan grafik (2-3 grafik)
‚ñ° Tulis pembahasan:
  - Kenapa thread lebih cepat?
  - Kenapa 8 workers tidak 2x lebih cepat dari 4 workers?
  - Apa yang terjadi saat dataset kecil vs besar?
  - Apa rekomendasi untuk industri?
```

#### MINGGU 8: Finalisasi Laporan

**Hari 28-30: Tulis BAB I, II, III**
```
‚ñ° BAB I: Copy template dari panduan ini, sesuaikan dengan konteks
‚ñ° BAB II: Masukkan 5-7 paper yang sudah dicari, tulis narasi
‚ñ° BAB III: Copy prosedur dari panduan ini, sesuaikan dengan kondisi real
```

**Hari 31-32: Tulis BAB V & Abstrak**
```
‚ñ° BAB V: Tulis kesimpulan (jawab rumusan masalah)
‚ñ° BAB V: Tulis saran untuk penelitian lanjutan
‚ñ° Abstrak: Ringkas BAB I-V dalam 150-250 kata
```

**Hari 33-34: Formatting & Revisi**
```
‚ñ° Set margin, line spacing, font sesuai aturan kampus
‚ñ° Buat daftar isi otomatis
‚ñ° Buat daftar tabel & gambar
‚ñ° Rapikan daftar pustaka (pakai Mendeley/Zotero)
‚ñ° Cek typo & grammar (pakai Grammarly)
```

**Hari 35: SUBMIT!**
```
‚ñ° Export ke PDF
‚ñ° Print 3 eksemplar
‚ñ° Submit ke dosen!
‚ñ° üéâ SELESAI!
```

### 3.3 Desain Eksperimen (DETAIL!)

#### Spesifikasi Hardware & Software

**Hardware:**
```
Laptop/PC yang digunakan:
- Processor: Intel Core i5-8250U (atau sejenisnya)
- RAM: 8 GB DDR4
- Storage: SSD 256 GB
- OS: Windows 10/11 atau Ubuntu 20.04
```

**Software:**
```
- Python: 3.8+
- concurrent.futures: (built-in)
- ReportLab: 3.6+
- PostgreSQL: 14+ (atau SQLite 3.x)
- Matplotlib: 3.5+
- Pandas: 1.4+
```

#### Variabel Eksperimen

**Variabel Independent (Yang Diubah-ubah):**

1. **Metode Pemrosesan:**
   - Sequential (baseline)
   - Parallel Threading

2. **Jumlah Worker Thread** (untuk metode Thread):
   - 2 workers
   - 4 workers
   - 8 workers

3. **Ukuran Dataset:**
   - 100 invoice (small)
   - 500 invoice (medium)
   - 1000 invoice (large)

**Variabel Dependent (Yang Diukur):**

1. **Waktu Eksekusi (T):** Total waktu dari mulai sampai selesai (detik)
2. **Throughput (Œò):** Jumlah invoice per detik (invoice/s)

**Variabel Kontrol (Dijaga Konstan):**

1. Algoritma generate PDF (sama untuk semua)
2. Kompleksitas invoice (simple template)
3. Hardware yang digunakan (laptop yang sama)
4. Waktu simulasi per invoice (80-200ms random)
5. Tidak ada aplikasi lain yang jalan (background apps di-close)

#### Prosedur Eksperimen

**Persiapan:**
```
1. Matikan aplikasi lain (Chrome, game, dll)
2. Pastikan laptop full battery atau di-charge
3. Pastikan laptop tidak overheat
4. Hapus file results.csv lama (kalau ada)
5. Siapkan stopwatch (sebagai backup timing)
```

**Eksekusi:**
```
Untuk setiap kombinasi (metode, workers, dataset_size):
    1. Jalankan command benchmark
    2. Tunggu sampai selesai
    3. Catat hasil di results.csv
    4. Istirahat 1 menit (biar sistem dingin lagi)
```

**Total Eksperimen:**
```
Sequential: 3 runs (100, 500, 1000)
Thread (2w): 3 runs (100, 500, 1000)
Thread (4w): 3 runs (100, 500, 1000)
Thread (8w): 3 runs (100, 500, 1000)

TOTAL: 12 runs
Estimasi waktu: 30-60 menit (tergantung spek laptop)
```

### 3.4 Metode Analisis Data

**Analisis Deskriptif:**
```
1. Buat tabel hasil (method, dataset_size, time, throughput)
2. Hitung mean (rata-rata) untuk setiap kombinasi
3. Buat grafik perbandingan:
   - Execution time vs dataset size
   - Throughput vs dataset size
   - Speedup vs number of workers
```

**Analisis Komparatif:**
```
1. Bandingkan waktu sequential vs thread (untuk setiap dataset size)
2. Hitung speedup: S = T_seq / T_thread
3. Bandingkan antar jumlah workers (2 vs 4 vs 8)
4. Tentukan jumlah worker optimal
```

**Interpretasi:**
```
1. Apakah thread lebih cepat dari sequential? (Ya/Tidak, berapa kali?)
2. Apakah lebih banyak worker = lebih cepat? (Tidak selalu! Ada overhead)
3. Pada dataset ukuran berapa thread paling efektif?
4. Apa rekomendasi untuk industri?
```

---

## üíª TEMPLATE KODE LENGKAP (TINGGAL COPY-PASTE!)

### File 1: `invoice_generator.py`

```python
"""
Invoice Generator Module
Generate PDF invoice sederhana menggunakan ReportLab
"""
import time
import random
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
import io

class InvoiceGenerator:
    """Generator invoice sederhana"""

    def generate(self, invoice_data):
        """
        Generate 1 invoice dalam format PDF

        Args:
            invoice_data (dict): Data invoice dengan format:
                {
                    'id': int,
                    'customer': str,
                    'amount': int
                }

        Returns:
            bytes: PDF content dalam bentuk bytes
        """
        # Buat buffer untuk PDF
        buffer = io.BytesIO()
        c = canvas.Canvas(buffer, pagesize=letter)

        # Header
        c.setFont("Helvetica-Bold", 16)
        c.drawString(100, 750, f"INVOICE #{invoice_data['id']}")

        # Customer info
        c.setFont("Helvetica", 12)
        c.drawString(100, 730, f"Customer: {invoice_data['customer']}")
        c.drawString(100, 710, f"Amount: Rp {invoice_data['amount']:,}")

        # Footer
        c.drawString(100, 100, "Thank you for your business!")

        # Save PDF
        c.save()

        # Simulasi waktu pemrosesan (I/O operation)
        # Waktu random 80-200ms untuk simulasi kompleksitas berbeda
        time.sleep(random.uniform(0.08, 0.2))

        return buffer.getvalue()
```

### File 2: `sequential_processor.py`

```python
"""
Sequential Processor Module
Process invoices satu per satu (sequential)
"""
import time
from invoice_generator import InvoiceGenerator

class SequentialProcessor:
    """Processor sequential (satu per satu)"""

    def __init__(self):
        """Initialize dengan invoice generator"""
        self.generator = InvoiceGenerator()

    def process(self, invoice_list):
        """
        Proses invoice satu per satu secara sequential

        Args:
            invoice_list (list): List of invoice data dict

        Returns:
            dict: Hasil eksperimen dengan format:
                {
                    'method': str,
                    'count': int,
                    'execution_time': float,
                    'throughput': float
                }
        """
        start_time = time.time()
        results = []

        # Process satu per satu
        for invoice_data in invoice_list:
            pdf = self.generator.generate(invoice_data)
            results.append(pdf)

        end_time = time.time()
        execution_time = end_time - start_time
        throughput = len(invoice_list) / execution_time

        return {
            'method': 'sequential',
            'count': len(invoice_list),
            'execution_time': execution_time,
            'throughput': throughput
        }
```

### File 3: `thread_processor.py`

```python
"""
Thread Processor Module
Process invoices secara parallel menggunakan thread
"""
import time
from concurrent.futures import ThreadPoolExecutor
from invoice_generator import InvoiceGenerator

class ThreadProcessor:
    """Processor parallel dengan thread"""

    def __init__(self, num_workers=4):
        """
        Initialize dengan invoice generator

        Args:
            num_workers (int): Jumlah worker threads dalam pool
        """
        self.num_workers = num_workers
        self.generator = InvoiceGenerator()

    def process(self, invoice_list):
        """
        Proses invoice secara parallel dengan thread

        Args:
            invoice_list (list): List of invoice data dict

        Returns:
            dict: Hasil eksperimen dengan format:
                {
                    'method': str,
                    'count': int,
                    'execution_time': float,
                    'throughput': float
                }
        """
        start_time = time.time()
        results = []

        # Buat thread pool
        with ThreadPoolExecutor(max_workers=self.num_workers) as executor:
            # Submit semua task ke thread pool
            futures = [executor.submit(self.generator.generate, inv)
                      for inv in invoice_list]

            # Tunggu semua selesai dan collect hasil
            for future in futures:
                results.append(future.result())

        end_time = time.time()
        execution_time = end_time - start_time
        throughput = len(invoice_list) / execution_time

        return {
            'method': f'thread_{self.num_workers}workers',
            'count': len(invoice_list),
            'execution_time': execution_time,
            'throughput': throughput
        }
```

### File 4: `run_benchmark.py`

```python
"""
Benchmark Runner Script
Script untuk menjalankan eksperimen dan catat hasil ke CSV
"""
import argparse
from sequential_processor import SequentialProcessor
from thread_processor import ThreadProcessor

def generate_dummy_data(count):
    """
    Generate dummy invoice data

    Args:
        count (int): Jumlah invoice yang akan digenerate

    Returns:
        list: List of invoice data dict
    """
    return [
        {
            'id': i,
            'customer': f'PT Customer {i}',
            'amount': 1000000 + (i * 50000)
        }
        for i in range(count)
    ]

def main():
    """Main function untuk run benchmark"""
    # Parse command line arguments
    parser = argparse.ArgumentParser(description='Invoice Batch Processing Benchmark')
    parser.add_argument('--method',
                       choices=['sequential', 'thread'],
                       required=True,
                       help='Processing method')
    parser.add_argument('--workers',
                       type=int,
                       default=4,
                       help='Number of workers (for thread method)')
    parser.add_argument('--invoices',
                       type=int,
                       required=True,
                       help='Number of invoices to process')
    args = parser.parse_args()

    # Generate data
    print(f"Generating {args.invoices} invoices...")
    invoice_data = generate_dummy_data(args.invoices)

    # Pilih processor berdasarkan method
    if args.method == 'sequential':
        processor = SequentialProcessor()
    else:
        processor = ThreadProcessor(num_workers=args.workers)

    # Jalankan benchmark
    print(f"Running {args.method} with {args.workers if args.method=='thread' else 1} workers...")
    result = processor.process(invoice_data)

    # Tampilkan hasil
    print(f"\n{'='*50}")
    print(f"Method: {result['method']}")
    print(f"Invoice count: {result['count']}")
    print(f"Execution time: {result['execution_time']:.2f} seconds")
    print(f"Throughput: {result['throughput']:.2f} invoices/second")
    print(f"{'='*50}\n")

    # Simpan ke file CSV
    with open('results.csv', 'a') as f:
        f.write(f"{result['method']},{result['count']},{result['execution_time']:.2f},{result['throughput']:.2f}\n")

    print(f"Results saved to results.csv")

if __name__ == '__main__':
    main()
```

### File 5: `visualize_results.py`

```python
"""
Visualization Script
Generate grafik perbandingan dari hasil eksperimen
"""
import pandas as pd
import matplotlib.pyplot as plt

def main():
    """Generate grafik dari results.csv"""

    # Baca hasil dari CSV
    df = pd.read_csv('results.csv',
                     names=['method', 'count', 'time', 'throughput'])

    # Setup figure dengan 2 subplot
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

    # Grafik 1: Execution Time Comparison
    for method in df['method'].unique():
        data = df[df['method'] == method]
        ax1.plot(data['count'], data['time'], marker='o', label=method, linewidth=2)

    ax1.set_xlabel('Number of Invoices', fontsize=12)
    ax1.set_ylabel('Execution Time (seconds)', fontsize=12)
    ax1.set_title('Execution Time Comparison', fontsize=14, fontweight='bold')
    ax1.legend()
    ax1.grid(True, alpha=0.3)

    # Grafik 2: Throughput Comparison
    for method in df['method'].unique():
        data = df[df['method'] == method]
        ax2.plot(data['count'], data['throughput'], marker='o', label=method, linewidth=2)

    ax2.set_xlabel('Number of Invoices', fontsize=12)
    ax2.set_ylabel('Throughput (invoices/second)', fontsize=12)
    ax2.set_title('Throughput Comparison', fontsize=14, fontweight='bold')
    ax2.legend()
    ax2.grid(True, alpha=0.3)

    # Save figure
    plt.tight_layout()
    plt.savefig('comparison_results.png', dpi=300, bbox_inches='tight')
    print("Grafik tersimpan di comparison_results.png")

    # Show figure
    plt.show()

if __name__ == '__main__':
    main()
```

---

## üìä BAB IV - HASIL DAN PEMBAHASAN (DENGAN CONTOH!)

### 4.1 Hasil Eksperimen

**Tabel 4.1: Hasil Perbandingan Waktu Eksekusi dan Throughput**

| Metode | Jumlah Invoice | Waktu (detik) | Throughput (inv/s) | Speedup |
|--------|----------------|---------------|-------------------|---------|
| Sequential | 100 | 12.5 | 8.0 | 1.00x (baseline) |
| Thread (2w) | 100 | 7.2 | 13.9 | 1.74x |
| Thread (4w) | 100 | 4.1 | 24.4 | 3.05x |
| Thread (8w) | 100 | 3.8 | 26.3 | 3.29x |
| Sequential | 500 | 62.3 | 8.0 | 1.00x |
| Thread (2w) | 500 | 35.1 | 14.2 | 1.77x |
| Thread (4w) | 500 | 19.1 | 26.2 | 3.26x |
| Thread (8w) | 500 | 17.8 | 28.1 | 3.50x |
| Sequential | 1000 | 124.8 | 8.0 | 1.00x |
| Thread (2w) | 1000 | 70.2 | 14.2 | 1.78x |
| Thread (4w) | 1000 | 38.7 | 25.8 | 3.22x |
| Thread (8w) | 1000 | 36.1 | 27.7 | 3.46x |

*(Ini contoh data, nanti kamu isi dengan data real hasil eksperimen kamu)*

**Grafik 4.1: Perbandingan Waktu Eksekusi**
```
[Insert gambar grafik line chart di sini]
X-axis: Jumlah Invoice (100, 500, 1000)
Y-axis: Waktu (detik)
Lines: Sequential, Thread 2w, Thread 4w, Thread 8w
```

**Grafik 4.2: Perbandingan Throughput**
```
[Insert gambar grafik line chart di sini]
X-axis: Jumlah Invoice
Y-axis: Throughput (invoice/s)
Lines: Sequential, Thread 2w, Thread 4w, Thread 8w
```

### 4.2 Analisis dan Pembahasan

#### 4.2.1 Perbandingan Sequential vs Parallel Threading

Dari hasil eksperimen pada Tabel 4.1, terlihat bahwa metode **parallel threading** memberikan peningkatan kinerja yang signifikan dibandingkan metode **sequential**.

Untuk dataset 1000 invoice:
- **Sequential:** 124.8 detik (throughput: 8.0 inv/s)
- **Thread (4 workers):** 38.7 detik (throughput: 25.8 inv/s)
- **Speedup:** 3.22x lebih cepat

Artinya, proses yang tadinya membutuhkan waktu **lebih dari 2 menit**, sekarang dapat diselesaikan dalam **kurang dari 40 detik**. Hal ini sangat signifikan untuk operasional perusahaan, dimana waktu adalah faktor kritis.

**Penjelasan Mengapa Thread Lebih Cepat:**

Pada metode sequential, invoice diproses satu per satu. Ketika sedang generate PDF untuk invoice ke-1 (yang melibatkan I/O operation), CPU idle menunggu I/O selesai sebelum memproses invoice ke-2. Ini sangat tidak efisien.

Pada metode thread, ketika thread-1 sedang waiting untuk I/O (generate PDF), thread-2, thread-3, dan thread-4 dapat memproses invoice lain secara concurrent. Meskipun Python memiliki GIL (Global Interpreter Lock), GIL akan **di-release saat I/O operation**, sehingga thread lain dapat mengambil GIL dan melanjutkan eksekusi. Inilah mengapa thread sangat efektif untuk **I/O-bound tasks** seperti generate invoice PDF.

#### 4.2.2 Pengaruh Jumlah Worker Threads

Dari hasil eksperimen, terlihat bahwa menambah jumlah worker thread memberikan peningkatan kinerja, namun tidak linear.

**Speedup berdasarkan jumlah worker (dataset 1000 invoice):**
- **2 workers:** 1.78x
- **4 workers:** 3.22x
- **8 workers:** 3.46x

Terlihat bahwa peningkatan dari 2 workers ke 4 workers signifikan (1.78x ‚Üí 3.22x), namun peningkatan dari 4 workers ke 8 workers tidak terlalu besar (3.22x ‚Üí 3.46x).

**Penjelasan:**

1. **Overhead Thread Management:**
   Semakin banyak thread, semakin besar overhead untuk thread scheduling, context switching, dan resource contention. Pada 8 workers, overhead ini mulai mengurangi benefit dari parallelism.

2. **Hardware Limitation:**
   Laptop yang digunakan memiliki 4 cores (asumsi Core i5 dengan 4 cores). Ketika menggunakan 8 threads pada 4 cores, akan terjadi thread contention dimana 2 threads harus share 1 core, yang mengurangi efisiensi.

3. **Amdahl's Law:**
   Tidak semua bagian dari program dapat di-parallelkan. Ada bagian sequential (seperti setup, finalization) yang membatasi maksimal speedup yang bisa dicapai.

**Jumlah Worker Optimal:**
Berdasarkan hasil eksperimen, **4 workers** adalah yang paling optimal untuk kasus ini, dengan efficiency 80.5% (3.22 / 4 = 0.805). Menggunakan 8 workers hanya meningkatkan speedup sedikit (3.46x) dengan efficiency lebih rendah (43.25%).

**Rekomendasi:**
Untuk I/O-bound tasks seperti invoice generation, gunakan **jumlah worker = jumlah CPU cores** (biasanya 4-8). Tidak perlu terlalu banyak karena overhead akan mengurangi benefit.

#### 4.2.3 Pengaruh Ukuran Dataset

Dari hasil eksperimen, terlihat bahwa speedup relatif konsisten untuk berbagai ukuran dataset:

| Dataset | Speedup (4 workers) |
|---------|---------------------|
| 100 invoice | 3.05x |
| 500 invoice | 3.26x |
| 1000 invoice | 3.22x |

Hal ini menunjukkan bahwa **parallel threading efektif untuk berbagai ukuran dataset**, bahkan untuk dataset kecil (100 invoice) sekalipun. Namun, untuk dataset yang sangat kecil (misalnya < 10 invoice), overhead thread creation mungkin lebih besar dari benefit parallelism, sehingga sequential lebih baik.

**Interpretasi:**
Parallel threading memberikan benefit yang konsisten terlepas dari ukuran dataset, selama dataset cukup besar untuk menutupi overhead thread creation (> 50-100 tasks).

#### 4.2.4 Implikasi untuk Industri

Hasil penelitian ini memberikan beberapa rekomendasi praktis untuk implementasi sistem batch processing invoice di industri:

1. **Gunakan Parallel Threading untuk Volume Besar:**
   Untuk perusahaan yang generate > 100 invoice per batch, parallel threading dapat menghemat waktu signifikan (3x lebih cepat).

2. **Jumlah Worker Optimal = Jumlah CPU Cores:**
   Tidak perlu menggunakan terlalu banyak worker. Untuk laptop dengan 4 cores, gunakan 4 workers saja.

3. **Cocok untuk I/O-Bound Tasks:**
   Invoice generation termasuk I/O-bound task (baca database, generate PDF, save file). Untuk task seperti ini, threading lebih efisien daripada multiprocessing.

4. **Scalability:**
   Sistem ini dapat di-scale dengan mudah. Untuk volume yang lebih besar (10,000+ invoice), dapat menggunakan distributed system atau cloud computing dengan prinsip yang sama.

---

## üìù BAB V - PENUTUP

### 5.1 Kesimpulan

Berdasarkan hasil penelitian dan pembahasan, dapat disimpulkan bahwa:

1. **Implementasi parallel threading berhasil meningkatkan kinerja batch processing invoice secara signifikan** dibandingkan metode sequential, dengan speedup rata-rata **3.2x lebih cepat** pada dataset 1000 invoice.

2. **Jumlah worker thread optimal untuk kasus ini adalah 4 workers**, yang memberikan speedup 3.22x dengan efficiency 80.5%. Menambah jumlah worker menjadi 8 hanya meningkatkan speedup sedikit (3.46x) dengan efficiency lebih rendah (43%).

3. **Parallel threading efektif untuk berbagai ukuran dataset**, dengan speedup konsisten antara 3.0-3.3x untuk dataset 100-1000 invoice. Hal ini menunjukkan bahwa metode ini scalable dan applicable untuk real-world use case.

4. **Python threading cocok untuk I/O-bound tasks** seperti invoice generation, dimana GIL di-release saat I/O operation, sehingga multiple threads dapat berjalan concurrent dengan efektif.

### 5.2 Saran

#### Saran untuk Penelitian Lanjutan:

1. **Perbandingan dengan metode lain:**
   Penelitian selanjutnya dapat membandingkan threading dengan metode concurrent programming lain seperti **multiprocessing** (ProcessPoolExecutor) dan **asyncio** untuk melihat metode mana yang paling efektif.

2. **Eksperimen dengan kompleksitas invoice berbeda:**
   Meneliti pengaruh kompleksitas invoice (simple vs complex layout) terhadap performance gain dari parallel threading.

3. **Distributed system:**
   Untuk volume yang sangat besar (100,000+ invoice), dapat diteliti implementasi dengan distributed system seperti Celery + RabbitMQ atau Apache Spark.

4. **Real-time monitoring:**
   Menambahkan fitur monitoring real-time untuk track progress batch processing dan alert jika ada error.

#### Saran untuk Implementasi di Industri:

1. **Gunakan parallel threading untuk batch size > 100 invoice** untuk mendapatkan speedup signifikan.

2. **Set jumlah worker = jumlah CPU cores** untuk efficiency optimal (biasanya 4-8 workers).

3. **Tambahkan error handling yang robust** untuk handle kasus dimana generate PDF gagal, sehingga tidak mengganggu batch processing keseluruhan.

4. **Implementasikan queue system** (seperti Celery) untuk production environment yang lebih complex, dengan fitur retry, priority queue, dan distributed processing.

5. **Monitor resource usage** (CPU, memory) untuk ensure sistem tidak overload saat processing volume besar.

---

## ‚úÖ CHECKLIST LENGKAP (56 Hari Step-by-Step)

### Minggu 1: Setup & Proposal

**Hari 1:**
- [ ] Install Python 3.8+ (test: `python --version`)
- [ ] Install VS Code + Python extension
- [ ] Buat folder project: `mkdir skripsi_invoice`

**Hari 2:**
- [ ] Buat virtual environment
- [ ] Install libraries: `pip install reportlab matplotlib pandas`
- [ ] Test import semua library (tidak ada error)

**Hari 3:**
- [ ] Tulis BAB I.1 Latar Belakang (copy template, sesuaikan)
- [ ] Tulis BAB I.2 Rumusan Masalah
- [ ] Tulis BAB I.3 Batasan Masalah

**Hari 4:**
- [ ] Tulis BAB I.4 Tujuan Penelitian
- [ ] Tulis BAB I.5 Manfaat Penelitian
- [ ] Email draft BAB I ke dosen untuk review

**Hari 5:**
- [ ] Buka Google Scholar
- [ ] Cari 5-7 paper dengan keyword yang disediakan
- [ ] Download semua paper (PDF)

**Hari 6:**
- [ ] Baca Abstract + Conclusion semua paper (15 menit per paper)
- [ ] Buat tabel penelitian terkait
- [ ] Tulis narasi penelitian terkait (1-2 halaman)

**Hari 7:**
- [ ] Tulis BAB II.2 Landasan Teori (copy dari template)
- [ ] Email draft BAB II ke dosen untuk review

### Minggu 2: Implementasi Sequential

**Hari 8:**
- [ ] Copy-paste kode `invoice_generator.py` dari template
- [ ] Jalankan test: generate 1 invoice
- [ ] Pastikan tidak ada error

**Hari 9:**
- [ ] Copy-paste kode `sequential_processor.py`
- [ ] Test: process 10 invoice
- [ ] Catat waktu eksekusi (berapa detik?)

**Hari 10:**
- [ ] Test sequential_processor untuk 100 invoice
- [ ] Catat hasil (waktu + throughput)
- [ ] Screenshot hasil untuk dokumentasi

**Hari 11:**
- [ ] (Opsional) Setup database SQLite
- [ ] Test koneksi database
- [ ] **ATAU skip database, pakai dummy data**

**Hari 12:**
- [ ] Tulis BAB III.1 Jenis Penelitian
- [ ] Tulis BAB III.2 Tahapan Penelitian (copy diagram dari template)

**Hari 13:**
- [ ] Tulis BAB III.3 Desain Eksperimen (variabel, prosedur)
- [ ] Tulis spesifikasi hardware yang kamu pakai

**Hari 14:**
- [ ] Email draft BAB III ke dosen untuk review
- [ ] Revisi BAB I & II kalau ada feedback dosen

### Minggu 3: Implementasi Thread

**Hari 15:**
- [ ] Copy-paste kode `thread_processor.py`
- [ ] Pahami cara kerja ThreadPoolExecutor (baca comment)

**Hari 16:**
- [ ] Test thread_processor dengan 2 workers, 100 invoice
- [ ] Catat hasil
- [ ] Bandingkan dengan sequential (lebih cepat?)

**Hari 17:**
- [ ] Test thread_processor dengan 4 workers
- [ ] Test thread_processor dengan 8 workers
- [ ] Bandingkan hasil

**Hari 18:**
- [ ] Debugging: pastikan tidak ada error
- [ ] Cek apakah semua PDF ter-generate dengan benar
- [ ] Tambah logging (print statement) untuk monitoring

**Hari 19:**
- [ ] Copy-paste kode `run_benchmark.py`
- [ ] Test jalankan: `python run_benchmark.py --method sequential --invoices 100`
- [ ] Pastikan hasil tersimpan di results.csv

**Hari 20:**
- [ ] Test jalankan untuk semua kombinasi (dry run)
- [ ] Verifikasi format results.csv benar
- [ ] Backup kode ke Google Drive / GitHub

**Hari 21:**
- [ ] Istirahat / buffer day (kalau ada yang tertinggal, kejar hari ini)

### Minggu 4: Persiapan Eksperimen

**Hari 22:**
- [ ] Generate dummy data 100 invoice (JSON/CSV)
- [ ] Generate dummy data 500 invoice
- [ ] Generate dummy data 1000 invoice

**Hari 23:**
- [ ] Backup semua dataset ke 3 tempat (Drive, USB, Email)
- [ ] Test load dataset (pastikan bisa dibaca)

**Hari 24:**
- [ ] Dry run SEMUA eksperimen (12 run)
- [ ] Catat hasil dry run (untuk perkiraan waktu)
- [ ] Identifikasi potential error

**Hari 25:**
- [ ] Matikan semua aplikasi lain
- [ ] Pastikan laptop full battery / di-charge
- [ ] Hapus file results.csv lama

**Hari 26: EKSPERIMEN DAY!**
- [ ] Jalankan SEMUA 12 eksperimen (1-2 jam)
- [ ] Catat semua hasil ke results.csv
- [ ] **BACKUP results.csv ke 3 tempat SEKARANG JUGA!**

**Hari 27:**
- [ ] Buka results.csv di Excel/Google Sheets
- [ ] Cek apakah ada data aneh (outlier)
- [ ] Kalau ada yang aneh, ulangi eksperimen tersebut

**Hari 28:**
- [ ] Buat tabel hasil yang rapi (untuk laporan)
- [ ] Hitung speedup untuk setiap kombinasi
- [ ] Hitung efficiency untuk thread

### Minggu 5-6: Analisis & Visualisasi

**Hari 29:**
- [ ] Copy-paste kode `visualize_results.py`
- [ ] Jalankan: `python visualize_results.py`
- [ ] Cek file comparison_results.png

**Hari 30:**
- [ ] Edit grafik (size, color, label) kalau perlu
- [ ] Buat grafik tambahan (bar chart speedup)
- [ ] Screenshot semua grafik (high resolution!)

**Hari 31:**
- [ ] Tulis BAB IV.1 Hasil Eksperimen
- [ ] Masukkan tabel hasil
- [ ] Masukkan grafik (2-3 grafik)

**Hari 32:**
- [ ] Tulis BAB IV.2.1 Perbandingan Sequential vs Thread (1 halaman)
- [ ] Jelaskan kenapa thread lebih cepat (GIL, I/O-bound)

**Hari 33:**
- [ ] Tulis BAB IV.2.2 Pengaruh Jumlah Worker (1 halaman)
- [ ] Jelaskan kenapa 8 workers tidak 2x lebih cepat dari 4 workers

**Hari 34:**
- [ ] Tulis BAB IV.2.3 Pengaruh Ukuran Dataset
- [ ] Tulis BAB IV.2.4 Implikasi untuk Industri

**Hari 35:**
- [ ] Review keseluruhan BAB IV
- [ ] Pastikan semua grafik & tabel jelas
- [ ] Email draft BAB IV ke dosen

**Hari 36:**
- [ ] Revisi BAB IV kalau ada feedback dosen
- [ ] Tambah interpretasi kalau perlu

**Hari 37:**
- [ ] Tulis BAB V.1 Kesimpulan (jawab semua rumusan masalah!)
- [ ] Tulis BAB V.2 Saran (untuk penelitian lanjutan & industri)

**Hari 38-40:**
- [ ] Buffer days (untuk kejar ketertinggalan atau perbaikan)

### Minggu 7: Finalisasi Laporan

**Hari 41:**
- [ ] Review & revisi BAB I (final check)
- [ ] Review & revisi BAB II (pastikan 5-7 paper ada)

**Hari 42:**
- [ ] Review & revisi BAB III (prosedur eksperimen jelas?)
- [ ] Review & revisi BAB IV & V

**Hari 43:**
- [ ] Tulis Abstrak (150-250 kata)
- [ ] Tulis Abstract (English version, kalau perlu)

**Hari 44:**
- [ ] Buat Cover sesuai template kampus
- [ ] Buat Kata Pengantar
- [ ] Buat Daftar Isi (auto-generate di Word)

**Hari 45:**
- [ ] Buat Daftar Tabel
- [ ] Buat Daftar Gambar
- [ ] Buat Daftar Pustaka (pakai Mendeley/Zotero)

**Hari 46:**
- [ ] Set margin sesuai aturan (biasanya: top 4cm, left 4cm, right 3cm, bottom 3cm)
- [ ] Set line spacing 1.5 atau double
- [ ] Set font Times New Roman 12pt

**Hari 47:**
- [ ] Numbering halaman (romawi untuk preliminaries, angka untuk isi)
- [ ] Cek typo & grammar (pakai Grammarly)
- [ ] Export ke PDF

### Minggu 8: Final Review & Submit

**Hari 48:**
- [ ] Print draft untuk review sendiri
- [ ] Baca keseluruhan laporan (cari typo, error)

**Hari 49:**
- [ ] Minta teman baca (cari second opinion)
- [ ] Email draft FINAL ke dosen untuk approval

**Hari 50-51:**
- [ ] Bimbingan dengan dosen (final review)
- [ ] Catat semua feedback

**Hari 52-54:**
- [ ] Revisi final sesuai feedback dosen
- [ ] Double-check semua perubahan

**Hari 55:**
- [ ] Export PDF final
- [ ] Print 3 eksemplar (hardcopy)
- [ ] Burn CD (kalau perlu)

**Hari 56: SUBMISSION DAY!**
- [ ] Submit ke TU/Jurusan
- [ ] Dapatkan tanda terima
- [ ] **üéâ SELESAI! SIAP SIDANG!**

---

## üÜò TROUBLESHOOTING SUPER LENGKAP

### Problem 1: "Error: pip tidak dikenali"
**Penyebab:** Python tidak ada di PATH

**Solusi:**
```
1. Uninstall Python
2. Install ulang, CENTANG "Add Python to PATH"
3. Restart CMD
4. Test: python --version
```

### Problem 2: "ModuleNotFoundError: No module named 'reportlab'"
**Penyebab:** Library belum di-install

**Solusi:**
```
pip install reportlab
```

Kalau masih error:
```
python -m pip install --upgrade pip
python -m pip install reportlab
```

### Problem 3: "Laptop lemot/hang saat eksperimen"
**Penyebab:** Resource tidak cukup atau terlalu banyak aplikasi jalan

**Solusi:**
```
1. Close semua aplikasi lain (Chrome, game, etc)
2. Restart laptop
3. Kurangi jumlah invoice (pakai 100, 300, 500 saja)
4. Kurangi max workers (pakai 2, 4 saja, jangan 8)
```

### Problem 4: "Hasil eksperimen tidak konsisten"
**Penyebab:** Background process ganggu

**Solusi:**
```
1. Matikan Windows Update saat eksperimen
2. Matikan antivirus sementara
3. Close all apps
4. Ulangi eksperimen 2-3x, ambil rata-rata
```

### Problem 5: "Gak ngerti cara baca paper"
**Solusi:**
```
JANGAN baca semua! Baca yang penting aja:

1. ABSTRACT (1 paragraf): Ini paper tentang apa?
2. INTRODUCTION paragraf terakhir: Kontribusi apa?
3. CONCLUSION: Hasil akhirnya apa?

Cukup 10 menit per paper!
Kalau bahasa Inggris susah, pakai Google Translate!
```

### Problem 6: "Grafik gak keluar / error matplotlib"
**Penyebab:** Backend matplotlib tidak support

**Solusi:**
```
pip install matplotlib
pip install pillow

# Kalau masih error, tambahkan di awal kode visualize_results.py:
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
```

### Problem 7: "Gak punya PostgreSQL"
**Solusi:** PAKAI SQLITE!
```
SQLite sudah built-in di Python, gak perlu install!

import sqlite3
conn = sqlite3.connect('invoice.db')
# Done!

ATAU lebih gampang: SKIP DATABASE, pakai dummy data aja!
```

### Problem 8: "Dosen minta statistik kompleks (t-test, ANOVA)"
**Jawaban untuk dosen:**
```
"Pak/Bu, untuk penelitian eksperimental dengan perbandingan kinerja,
statistik deskriptif (mean, speedup) sudah cukup untuk menunjukkan
perbedaan yang signifikan. Perbedaan 3.2x (sequential vs thread)
sudah jelas terlihat tanpa perlu uji statistik inferensial."

Kalau tetap diminta, bilang:
"Baik Pak/Bu, saya akan tambahkan t-test untuk membandingkan mean
waktu eksekusi sequential vs thread."

Trus pakai SciPy:
from scipy import stats
t_stat, p_value = stats.ttest_ind(sequential_times, thread_times)
print(f"p-value: {p_value}")

Kalau p_value < 0.05, berarti "significantly different"
```

### Problem 9: "Waktu habis, gak sempat 8 minggu"
**Solusi Emergency (Versi 4 Minggu):**
```
MINGGU 1: BAB I & II (copy template, cari 5 paper)
MINGGU 2: Implementasi kode (sequential + thread)
MINGGU 3: Eksperimen + BAB IV
MINGGU 4: BAB V + Finalisasi

Kurangi:
- Paper dari 7 jadi 5
- Eksperimen dari 12 jadi 6 (cuma 1 ukuran data: 500 invoice)
- Grafik dari 3 jadi 1
- Revisi hanya 1x

Tetap bisa selesai! (Tapi lebih stress)
```

### Problem 10: "Sidang ditanya hal yang gak ada di skripsi"
**Persiapan Sidang:**
```
Pertanyaan yang mungkin muncul:

Q: "Kenapa tidak pakai multiprocessing?"
A: "Invoice generation adalah I/O-bound task. Untuk I/O-bound,
    threading lebih efisien karena overhead lebih kecil. Multiprocessing
    lebih cocok untuk CPU-bound tasks."

Q: "Kenapa tidak pakai machine learning?"
A: "Fokus penelitian ini adalah optimization menggunakan parallel
    processing, bukan prediction atau classification yang memerlukan ML."

Q: "Bagaimana kalau dataset 100,000 invoice?"
A: "Untuk skala yang sangat besar, dapat menggunakan distributed system
    seperti Celery + RabbitMQ atau Apache Spark dengan prinsip yang sama."

Q: "Apa kontribusi ilmiahnya?"
A: "Memberikan baseline performance untuk Python threading pada batch
    invoice generation, serta rekomendasi praktis untuk industri."
```

---

## üí™ MOTIVASI & TIPS AKHIR

### Motivasi:
```
Hari 1:  "Ini akan lama..." üò∞
Hari 14: "Kode udah jalan!" üòä
Hari 28: "Setengah jalan!" üí™
Hari 42: "Hampir selesai!" üòé
Hari 56: "SELESAI! WISUDA!" üéâüéì
```

### Tips Produktivitas:
1. **Kerja pagi hari** (06:00-10:00): Otak paling fresh!
2. **Pomodoro technique:** 25 menit fokus, 5 menit istirahat
3. **Matikan notifikasi HP** saat kerja
4. **Track progress** dengan checklist (dopamine boost!)
5. **Celebrate small wins:** Setiap milestone, treat yourself!

### Mindset yang Benar:
```
‚ùå "Harus perfect!"
‚úÖ "Done is better than perfect!"

‚ùå "Harus publish journal!"
‚úÖ "Tujuan gua cuma lulus S1!"

‚ùå "Takut salah..."
‚úÖ "Trial & error is part of learning!"

‚ùå "Nanti aja deh..."
‚úÖ "MULAI SEKARANG!"
```

---

## üéØ KESIMPULAN AKHIR

**Panduan ini SUDAH SANGAT LENGKAP dengan:**

‚úÖ Penjelasan konsep dari NOL (GIL, Thread, Sequential, dll)
‚úÖ Template BAB I-V lengkap
‚úÖ Cara mencari & membaca paper (step-by-step!)
‚úÖ Kode 80% sudah jadi (tinggal copy-paste!)
‚úÖ Prosedur eksperimen detail (command-by-command!)
‚úÖ Checklist 56 hari (day-by-day tasks!)
‚úÖ Troubleshooting lengkap (10+ common problems!)
‚úÖ Contoh interpretasi hasil
‚úÖ Panduan persiapan sidang

**Rizky, kamu PASTI BISA!**

---

**GOOD LUCK! SEMANGAT! üöÄ**
